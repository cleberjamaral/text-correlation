b'\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nPlan Library Reconfigurability in BDI Agents?\\n\\nRafael C. Cardoso, Louise A. Dennis, and Michael Fisher\\n\\nUniversity of Liverpool, Liverpool L69 3BX, United Kingdom\\n{rafael.cardoso,L.A.Dennis,mfisher}@liverpool.ac.uk\\n\\nAbstract. One of the major advantages of modular architectures in\\nrobotic systems is the ability to add or replace nodes, without need-\\ning to rearrange the whole system. In this type of system, autonomous\\nagents can aid in the decision making and high-level control of the robot.\\nHowever, when autonomously replacing a node it can be difficult to re-\\nconfigure plans in the agent\\xe2\\x80\\x99s plan library while retaining correctness. In\\nthis paper, we exploit the formal concept of capabilities in Belief-Desire-\\nIntention agents and describe how agents can reason about these capa-\\nbilities in order to reconfigure their plan library while retaining overall\\ncorrectness constraints. To validate our approach, we show the implemen-\\ntation of our framework and an experiment using a practical example in\\nthe Mars rover scenario.\\n\\nKeywords: Belief-Desire-Intention \\xc2\\xb7modular architectures \\xc2\\xb7 autonomous\\nagents \\xc2\\xb7 reconfigurability.\\n\\n1 Introduction\\n\\nRobots have been frequently used in real world applications over the years,\\nfrom industrial robotics [30] to teleoperated robots in search and rescue [24].\\nHowever, there are still many open challenges such as: the German strategic\\ninitiative Industrie 4.0 that encourages research in the intelligent networking of\\nmachines; and robot assisted disaster response in the TRADR project [19]. The\\nreconfigurability problem originally stemmed from manufacturing systems [18],\\nbut has since been expanded to self-reconfigurable robots [5,31] that can adapt\\nto different situations via proper selection and reconfiguration of the functional\\ncomponents and the software that are available.\\n\\nDue to the complexity present in these challenges modular architectures are\\ntypically employed to speed up and make the development of robotic systems\\neasier. The Robot Operating System (ROS) [26] is an example of a popular\\nmiddleware that can be used to develop a modular robotic system. In ROS,\\nnodes are used to effectively capture robotic software in terms of a graph that\\ndescribes the communication between distinct nodes. Some of the advantages\\nof decoupling the system in this way include: more precise failure handling and\\nrecovery mechanisms, since failures can be traced to individual nodes; and the\\n\\n? Work supported by UK Research and Innovation Hubs for \\xe2\\x80\\x9cRobotics and AI in\\nHazardous Environments\\xe2\\x80\\x9d: EP/R026092 (FAIR-SPACE), and EP/R026084 (RAIN).\\n\\nlouisedennis\\nPlaced Image\\n\\n\\n\\n2 R. C. Cardoso et al.\\n\\ncomplexity of the code is reduced when compared to monolithic systems, making\\nit easier to add, replace, or remove functionality (i.e., nodes).\\n\\nAgent-based control allows a system to dynamically adapt to changes in the\\nenvironment through the use of modularity, decentralisation, autonomy, scala-\\nbility, and reusability [20]. Many of these systems use cognitive agents, partic-\\nularly those in the Belief-Desire-Intention (BDI) paradigm. Kohn and Nerode\\xe2\\x80\\x99s\\nMAHCA system [17] uses multiple knowledge-based agents as planners which\\ngenerate the actions performed by the underlying control system. While these\\nagents are not based on the BDI paradigm, which was only in its infancy when\\nMAHCA was originally developed, the approach was designed to represent log-\\nical decision-making in a high-level declarative fashion. Recent agent-based ap-\\nproaches have been use in networks of autonomous agents interacting to solve\\ncomplex and dynamic problems in manufacturing and supply chain decision mak-\\ning [22], and explored in the control of spacecraft [25], Unmanned Aircraft [33],\\nand robotics [34]. Many of these approaches are explicitly BDI-based that aim\\nto separate the symbolic and non-symbolic reasoning, and to model the mission\\ndesigner\\xe2\\x80\\x99s intent.\\n\\nModular architectures for robotic systems often require a framework for re-\\nconfigurability, allowing modules to be added and replaced should the need arise\\n(e.g., in case of node failure). Several types of reconfigurability can be identified\\nin these systems [8]: (i) reconfiguration at the hardware level, for instance the\\ndynamic reconfiguration of effectors and sensors to cope with a hardware change;\\n(ii) reconfiguration due to low-level control, such as ROS node reconfiguration\\nand being able to replace nodes while still maintaining a working graph; (iii)\\nreconfiguration due to high-level control, for example reconfiguring an agent\\xe2\\x80\\x99s\\ngoals, plans, and knowledge.\\n\\nIn this paper, we introduce the reconfigurability of plan libraries in BDI\\nagents [27]. Specifically, our approach is aimed towards modular architectures\\nand applications that detect anomalies or malfunctions in a capability (an ex-\\ntended action specification) and can then reason about replacing it with al-\\nternative capabilities that are able to achieve the desired outcome. We use the\\nBDI-based agent-oriented programming language Gwendolen [6] to implement\\nour framework. By using this language, we can formally verify our new plan li-\\nbrary using a program model checker, an important, and necessary [10], step\\ntowards the validation and reliability of the framework and its applications.\\n\\nIn the next section we provide a background on BDI agents and clarify the\\ndistinction between actions and capabilities. Section 3 introduces our recon-\\nfigurability framework, with an overview of the overall system and a running\\nexample. Then, we provide a formal description of capabilities and plan replace-\\nment in propositional logic. In Section 4 we describe our implementation of\\nreconfigurability in the Gwendolen language, and then demonstrate its use in\\na practical experiment in the Mars rover scenario. Section 5 covers the related\\nwork, from purely theoretical approaches to application-based solutions. We end\\nthe paper in Section 6 with our conclusions and future work.\\n\\n\\n\\nPlan Library Reconfigurability in BDI Agents 3\\n\\n2 BDI Agent Programming Languages and Capabilities\\n\\nAgents programmed using BDI languages commonly contain a set of beliefs,\\nrepresenting the agent\\xe2\\x80\\x99s current state and knowledge about the environment in\\nwhich it is situated; a set of goals, tasks that the agent aims to achieve; a set\\nof intentions, tasks that the agent is committed to achieve; and a set of plans,\\ncourses of actions that are triggered by events. Events can be related to changes\\nin the agents belief base or to the addition or removal of goals. The agent reacts\\nto these events by creating new intentions which are generated from the set of\\napplicable plans related to that event.\\n\\nThe body of a plan often contains a set of actions that can cause changes in\\nthe environment. Languages such as Jason, Gwendolen, and 2APL delegate\\nthese actions\\xe2\\x80\\x99 specifications to the environment. Any preconditions or postcon-\\nditions (i.e., effects) that such actions may have are invisible to the agent and\\nare dealt with at the environment level. The environment may return some value\\nto be unified with an open variable or, for example, in Jason it may also return\\na failure condition which will trigger the removal of the event that started the\\nplan (plan failure).\\n\\nIt is possible to specify an action\\xe2\\x80\\x99s pre and postconditions at the agent level\\nusing these languages, for example by creating a dummy plan with only one\\naction, and writing the preconditions of the actions as the preconditions of the\\nplan. The postconditions, if any, could then be written as belief operations (add\\nor remove) to be executed after the action finishes. However, this is not how BDI\\nagents are traditionally programmed in those languages and it can be difficult\\nto reason about an action\\xe2\\x80\\x99s pre and postconditions programmed this way.\\n\\nThese actions can also be modelled as capabilities. The main difference be-\\ntween them is the explicit specification of pre and postconditions. A capability\\ncan only be executed when its preconditions are true, and any postconditions\\nthat it has are added when the capability ends with success. This kind of action\\ntheory is more prominent in automated planning, known as actions in classical\\nplanning [12] or primitive tasks (also operators) in Hierarchical Task Network\\n(HTN) planning [32]. BDI languages that implement this concept of capability\\ninclude GOAL, 3APL, and 2APL (only for belief update actions).\\n\\nThe problem that we are interested in solving is improving the system\\xe2\\x80\\x99s\\nability to adapt its behaviour in the event of a (software) failure or damage to\\nsome of its (physical) sub-systems in such a way that it can continue to achieve\\nsome, or all, of its goals. A BDI-agent is involved at the highest decision-making\\nlevel of the system, and as such, we want the agent to be able to recognise that a\\ncomponent is no longer behaving as expected, then invoke diagnosis subsystems\\nto identify the actions related to the failure, and lastly reconfigure the agent\\xe2\\x80\\x99s\\nplan library to cope with the failure. We note that failure detection and diagnosis\\nin agents is touched on, for example, with semantics for adding duration and\\nfailure information in actions for the life-cycle of goals in [7], and through the\\nuse of trace expressions to specify protocols on top of sets of events (such as\\nmessages, beliefs, and actions) to be checked at runtime through the use of\\n\\n\\n\\n4 R. C. Cardoso et al.\\n\\nautomatically generated monitors [11]. Such mechanisms are assumed to be in\\nplace and are not a part of the framework that we describe in this paper.\\n\\n3 Reconfigurability Framework\\n\\nOur framework is aimed towards systems that have a similar architecture to\\nthe one represented in Figure 1. The system goes through phases of potentially\\ntime critical operations followed by an offline phase in which it can reason about\\nfailure, perform reconfiguration, and if necessary reverify any relevant system\\nproperties. When such a system is deployed, the execution of its capabilities is\\nmonitored (e.g., with runtime monitors [11]). If a capability is detected as faulty,\\nthen the reconfiguration process tries to replace calls to the faulty capability with\\nviable alternatives, which may include one or multiple capabilities.\\n\\nSystem\\xc2\\xa0execution\\xc2\\xa0\\n\\nSystem\\xc2\\xa0deployment\\xc2\\xa0\\n\\nFaulty\\xc2\\xa0capability\\xc2\\xa0\\xc2\\xa0\\ndetected?\\xc2\\xa0\\n\\nAny\\xc2\\xa0plans\\xc2\\xa0\\xc2\\xa0\\nwere\\xc2\\xa0replaced?\\xc2\\xa0\\n\\nReconfiguration\\xc2\\xa0\\n\\nProgram\\xc2\\xa0Model\\xc2\\xa0Checking\\n\\nYes\\n\\nYes\\n\\nOffline\\xc2\\xa0period\\xc2\\xa0\\n\\nNo\\n\\nNo\\n\\nFig. 1. Overview of the system.\\n\\nWe assume that the system has an offline period, which is very common in\\nrobotic systems with long-term autonomy (see [15] for example). During this\\nperiod the robot can recharge and perform cleanup operations, among other\\nthings. But, more importantly from our point of view, it can also reconfigure\\nitself if any faults were detected and verify any plans that were replaced using,\\n\\n\\n\\nPlan Library Reconfigurability in BDI Agents 5\\n\\nfor example, a program model checker for agent programming languages. We\\nfocus on the formal definition and implementation of the reconfigurability of plan\\nlibraries in BDI agent(s) that perform high-level reasoning within the system.\\n\\n3.1 Running Example\\n\\nRobots are increasingly deployed to explore hazardous environments that are\\ndangerous for human exploration and often safety-critical, such as areas with\\nextreme temperatures (monitoring of offshore structures [29]), lack of oxygen\\n(both orbital [13] and planetary [35] space exploration), or high radiation (nu-\\nclear inspection and decommissioning [3]). Autonomous robots are especially\\nimportant in scenarios with communication bottlenecks, for example, in plane-\\ntary space exploration it can take a very long time for human operators to send\\ncommands from Earth to the robots. One such example is the Mars rovers used\\nby NASA1 in several missions. In this scenario an autonomous rover vehicle tra-\\nverses the surface of Mars collecting image, soil, and rock data. For our example\\nwe assume that the rover has access to a topological map, which indicates areas\\nof interest (denoted by waypoints) where the rover can collect data.\\n\\nThe Mars rover scenario can easily be seen as a system that matches the\\noverview depicted in Figure 1. While in execution mode, the rover traverses\\nthrough routes in the topological map, collecting data at each waypoint. The\\nrover\\xe2\\x80\\x99s offline period happens, for instance, during the night when it can not\\nrecharge using its solar panels and must conserve energy by remaining stationary.\\n\\nSpecifically, in this scenario we are interested in modelling the agent that is\\nresponsible for autonomously controlling the rover at a high-level. The actions\\nthat the agent can perform include moving between waypoints in a topological\\nmap, charging its batteries, collecting soil, collecting data, and taking images.\\n\\n3.2 Preliminaries\\n\\nPropositional Logic. We adopt a language of propositional logic L with formula\\n\\xcf\\x86 defined over a finite set of literals, L, and with >,\\xe2\\x8a\\xa5 \\xe2\\x88\\x88 L denoting the true\\nand false connectives respectively. We also use a finite set of abstract states S\\nwith element s and an entailment relation s |=L \\xcf\\x86 which defines when formula\\n\\xcf\\x86 holds in s.\\n\\nAs previously mentioned in Section 2, actions form the body of a BDI plan.\\nWhen these actions are executed, some parameters may need to be instantiated\\n(this is typically done by unification). We use the notation t\\xce\\xb8 to indicate the\\napplication of a unifier, \\xce\\xb8, to a term t.\\n\\n3.3 Capabilities\\n\\nOur formal representation of capabilities is based on the action theory found in\\nclassical automated planning, such as STRIPS reasoning [12], situation calcu-\\nlus [28], and the Planning Domain Definition Language (PDDL) [23]. As such,\\n\\n1\\nhttps://mars.nasa.gov/\\n\\nhttps://mars.nasa.gov/\\n\\n\\n6 R. C. Cardoso et al.\\n\\nour formalism is deliberately close to those, but a key difference is that we do not\\nplan from scratch. We discuss the relationship between our work and planning\\nsystems in related work (Section 5).\\n\\nA capability specification describes an action that an agent can take and any\\nrelation it has to the internal (self) and external (environment) facts of the agent.\\nThe specification is in the form of a set of preconditions and postconditions for\\nthe action. If the preconditions hold before the action is performed then the\\naction specification states that eventually, if the action terminates with success,\\nthe postconditions will hold.\\n\\nCapability Specification. We use the notation {Cpre}C {Cpost} where C is the\\ncapability, Cpre are the preconditions and Cpost are the postconditions. C, Cpre,\\nand Cpost are all formulas \\xcf\\x86 \\xe2\\x88\\x88 L.\\n\\nCapability Example. The move action of a rover can be represented as:\\n\\nC = {at(X1), notX1 = X2}move(X1, X2) {not at(X1), at(X2)}\\n\\nsuch that X1 is the current position of the rover, and X2 is the desired desti-\\nnation. Following the capability specification, we know that the rover must be\\nat(X1) (precondition), and after the end of the execution it must be at(X2)\\n(postcondition). The purpose of not at(X1) in the postcondition is to delete the\\nprevious belief at(X1). This is needed since most agent programming languages\\nallow multiple beliefs with the same predicate name.\\n\\nReasoning about the Execution of a Capability. The notation do(C\\xce\\xb8) indicates\\nthe execution of a capability, with its parameters instantiated by the \\xce\\xb8 unifier.\\nThe execution defines a transition on states in S that is completely specified by\\nthe specification of C. That is, if s \\xe2\\x88\\x88 S and s |=L Cpre\\xce\\xb8 there is some unique\\nstate s\\xe2\\x80\\xb2 \\xe2\\x88\\x88 S such that:\\n\\ns\\ndo(C\\xce\\xb8)\\n\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92s\\xe2\\x80\\xb2 and s\\xe2\\x80\\xb2 |=L Cpost\\xce\\xb8\\n\\nAs discussed in Section 2, many BDI systems employ a simplistic action\\ntheory where the pre and postconditions of actions are not represented at the\\nexecution level of the agent. Thus, it is always possible to execute actions in\\nthose systems as long as the preconditions of the plan hold when the plan was\\nselected. Our theory of plan validity (see next section) assumes that capability\\nspecifications are complete and correct and that the preconditions of a capability\\nalways hold when the system attempts to execute the associated action.\\n\\nExecution Example. Suppose that in state s the proposition empty(true) holds\\nand the next action in the plan to be executed is the capability collect sample\\nwith postcondition empty(false):\\n\\ns\\ndo(collect sample)\\n\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92s\\xe2\\x80\\xb2\\n\\nresults in a state where empty(false) holds.\\n\\n\\n\\nPlan Library Reconfigurability in BDI Agents 7\\n\\n3.4 Plans\\n\\nA BDI plan is a structure which contains a sequence of capabilities as its body,\\nbut may also contain additional elements such as trigger events or guards. For\\nsimplicity, we ignore these additional elements in a plan body when reasoning\\nabout plan replacements, but we point out that most of these elements could be\\nrepresented as capabilities.\\n\\nPlan Specification. Given a plan, P , we write its preconditions as Ppre and its\\npostconditions as Ppost. We use the notation C = [C\\n\\n1;C2; . . . ;Cn] to indicate\\na sequence of capabilities that are to be executed as part of the body, C, of\\na BDI plan. Our theory assumes that capabilities are guaranteed to execute\\nsequentially, i.e., Ci+1 is not executed until Cipost holds.\\n\\nPlan Body Example. We have a plan, P 1 to collect a rock sample at a particular\\nposition and then transmit the data. The body of this plan, C1, consists of a\\nsequence of four capabilities:\\n\\nC1 = [move(X1, X2); collect sample(S); move(X2, X3); transmit data(S)]\\n\\nThe first moves the rover to a position where it is capable of collecting a rock\\nsample, performs the collection, then moves to a position where it can transmit\\nthe data, and finally performs the transmission.\\n\\nMany BDI-based languages already allow the specification of preconditions\\nin plans (e.g., plan context in Jason, or plan guards in Gwendolen), but it is\\nunusual for a BDI plan to have explicit postconditions. However, we believe these\\ncan often be understood implicitly from the postconditions of the capabilities in\\na plan\\xe2\\x80\\x99s body.\\n\\nPre and postcondition Example. Using the plan from the previous example, P 1,\\nwe can complete the plan specification by adding P 1pre = [at(X1), empty(true)]\\nand P 1post = [data transmitted(S)] as such:\\n\\nP 1 = {at(X1), empty(true)}C1 {data transmitted(S)}\\n\\nmeaning that for the plan to be applicable the rover must be at waypoint X1\\nand it must not be carrying any sample, and after the plan\\xe2\\x80\\x99s conclusion the data\\nof S will have been transmitted.\\n\\nWe represent pre and postconditions for plans explicitly because even though\\ntwo capabilities may have different postconditions it may be the case that one\\ncan be replaced by another in a plan, without changing what the plan is intended\\nto achieve.\\n\\nIt may occur that the postcondition of a plan does not include all of the\\neffects from the execution of the capabilities in the plan body (i.e., Ppost 6=\\nC1post \\xe2\\x88\\xaa . . . \\xe2\\x88\\xaaCnpost). For example, the proposition at(X2) is not a postcondition\\nof P 1 since in this case we do not care if the final position of the rover is X2,\\nonly that it has successfully transmitted the data. This may be achievable from\\nother waypoints, allowing the plan to be modified in a fashion that would have\\nthe rover transmitting data from a different waypoint.\\n\\n\\n\\n8 R. C. Cardoso et al.\\n\\nSimple Plan Trace. A simple plan trace is one in which only the capabilities in the\\nplan body cause state transitions in S. That is, the environment does not change\\napart from the execution of those capabilities and the plan\\xe2\\x80\\x99s execution has not\\nbeen interleaved with the execution of any other plan. Formally, let [C1; . . . ;Cn]\\nform the body of some plan, P . Then a sequence of states s1; . . . ; sn+1 together\\n\\nwith a unifier, \\xce\\xb8, forms a simple plan trace for P if for all si, si\\ndo(Ci\\xce\\xb8)\\n\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92si+1.\\n\\n3.5 Plan Replacement\\n\\nWhen reasoning about plan replacement we assume an idealised execution envi-\\nronment for the plan represented by a simple plan trace. We ignore any impact\\nthat the environment (or another external factor) might have in the outcome\\nof a capability, as these would be impossible to predict. The end system may\\nstill have them and they may make a plan that was replaced fail, but we do\\nnot address this issue in this paper, since this is not directly related to the\\nreconfigurability problem.\\n\\nDefinition 1 (Valid Plan). We say a plan P with a body consisting of the\\nsequence of capabilities [C1; . . . ;Cn] is valid with regards to the specifications of\\nthe capabilities, if for all simple plan traces, \\xe3\\x80\\x88s1; . . . ; sn+1, \\xce\\xb8\\xe3\\x80\\x89 where \\xce\\xb8 instanti-\\nates all the parameters of all the specifications for capabilities in the body of P ,\\nsi |=L Cipre\\xce\\xb8 for all Ci. That is, the precondition in the specification for the next\\ncapability in the plan holds when some capability is executed.\\n\\nNote that plans in an actual BDI program may not be valid w.r.t. to the actions\\xe2\\x80\\x99\\nspecifications since they have been supplied by a programmer, not constructed\\nfrom the specifications. In this case, these plans would need to be fixed, either\\nby an automatic algorithm or by hand, to be considered as valid plans and able\\nto be replaced.\\n\\nDefinition 2 (Valid Plan Specification). We say that a plan specification\\nP = {Ppre}C{Ppost} for a plan with body [C1; . . . ;Cn] is valid if\\n1. P is valid;\\n2. Ppre \\xe2\\x86\\x92 C1pre; and\\n3. for all simple plan traces, \\xe3\\x80\\x88s1; . . . ; sn+1, \\xce\\xb8\\xe3\\x80\\x89 where \\xce\\xb8 instantiates all the pa-\\n\\nrameters in the specifications of capabilities appearing in the body of P and\\nall free variables in Ppre and Ppost, if s1 |=L Ppre\\xce\\xb8 then sn+1 |=L Ppost\\xce\\xb8.\\n\\nThe first point is covered in Definition 1. The second point states that if the\\npreconditions of the plan holds before its execution, then the preconditions of\\nthe first capability in that plan\\xe2\\x80\\x99s body also hold. The third point declares that\\na plan specification is valid if it can establish its postconditions on simple plan\\ntraces. That is, if the precondition of a plan hold before execution of the plan,\\nthen the plan\\xe2\\x80\\x99s postconditions hold after its execution.\\n\\nOnce again, we assume a static environment where all capabilities behave\\naccording to their specification. Note that this does not guarantee that the plan\\nalways works, only that it has been specified appropriately and sensibly pro-\\ngrammed to work in most situations where it is invoked.\\n\\n\\n\\nPlan Library Reconfigurability in BDI Agents 9\\n\\nDefinition 3 (Preservation of Plan Spec. Validity). Consider a plan spec-\\nification P = {Ppre}C{Ppost}. Let P \\xe2\\x80\\xb2 be a plan that has identical pre and post-\\nconditions to P except that P \\xe2\\x80\\xb2 has body C \\xe2\\x80\\xb2. We say that P \\xe2\\x80\\xb2 preserves the validity\\nof P if P \\xe2\\x80\\xb2 = {Ppre}C \\xe2\\x80\\xb2{Ppost} is valid.\\n\\nWe argue that the preservation of plan specification validity is a minimal require-\\nment when replacing plans. It states that if there is a static environment and\\nno interleaved execution of plans, then the new plan will achieve the replaced\\nplan\\xe2\\x80\\x99s postconditions.\\n\\nDefinition 4 (Rational Plan Body Replacement). We say the replacement\\nof plan body C for C \\xe2\\x80\\xb2 in a plan P so it becomes a plan P \\xe2\\x80\\xb2 is rational if P \\xe2\\x80\\xb2\\n\\npreserves the validity of P .\\n\\nTherefore we seek to implement mechanisms for plan body replacement that are\\nrational.\\n\\nPlan Body Replacement Example. If we detect a capability in the previous plan\\nP 1 to be faulty, for example, the rover can no longer move from the place it\\ncollected the rock sample to a place to transmit the data due to an unavoidable\\nobstacle. Then, the capability move(X2, X3) can be exchanged in the plan body\\nreplacement:\\n\\nC1\\n\\xe2\\x80\\xb2\\n\\n=\\n\\n[\\nmove(X1, X2); collect sample(S); move(X2, X4);\\nmove(X4, X3); transmit data(S)\\n\\n]\\nwith X3 representing an intermediate waypoint between X2 and the goal position\\nX3 and that this route is obstacle-free. This is a rational plan body replacement:\\nthe new plan P 1\\n\\n\\xe2\\x80\\xb2\\n= {at(X1), empty(true)}C1\\n\\n\\xe2\\x80\\xb2 {data transmitted(S)} is a valid\\nplan which achieves P 1\\xe2\\x80\\x99s postconditions whenever P 1\\xe2\\x80\\x99s preconditions are true.\\n\\n4 Implementation\\n\\nWe have implemented our theory as an extension of the Gwendolen program-\\nming language [6], chosen for its association with the Agent Java Pathfinder\\n(AJPF) model-checker [9]. This provides a potential route for verification of a\\nreconfigured plan library. To simplify implementation, we only use grounded\\ncapabilities in our practical experiment.\\n\\nAlgorithm 1 shows a high-level abstraction of our implementation for recon-\\nfigurability of plan libraries in BDI agents. Due to the availability and accessibil-\\nity of implementations of fast classical planners, we opted to translate the search\\nfor the replacement of plan bodies into a limited planning problem. Limited here\\nrefers to the use of a very small subset of information, instead of planning from\\nscratch.\\n\\nWe start the reconfiguration of the plan library when a capability is detected\\nto be faulty and in need of a replacement. First, we retrieve all capabilities that\\n\\n\\n\\n10 R. C. Cardoso et al.\\n\\nAlgorithm 1: Implementation of plan library reconfigurability.\\n\\n1 Function replace (capability)\\n2 Capabilities\\xe2\\x86\\x90 get capabilities;\\n3 Capabilities\\xe2\\x86\\x90 Capabilities \\\\ {capability};\\n4 if Capabilities = \\xe2\\x88\\x85 then\\n5 return false;\\n\\n6 domain\\xe2\\x86\\x90 create domain (Capabilities);\\n7 PlanLibrary \\xe2\\x86\\x90 get plan library;\\n8 Plans\\xe2\\x86\\x90 get plans (capability);\\n9 while there exists {plan} \\xe2\\x88\\x88 Plans do\\n\\n10 InitState\\xe2\\x86\\x90 propagate (plan, capability);\\n11 Goals\\xe2\\x86\\x90 get post cond (plan);\\n12 problem\\xe2\\x86\\x90 create problem (InitState, Goals);\\n13 replacement\\xe2\\x86\\x90 STRIPS planner (domain, problem);\\n14 if replacement = \\xe2\\x88\\x85 then\\n15 return false;\\n\\n16 newplan\\xe2\\x86\\x90 replace cap (plan, replacement);\\n17 PlanLibrary \\xe2\\x86\\x90 PlanLibrary \\\\ {plan} \\xe2\\x88\\xaa {newplan};\\n18 Plans\\xe2\\x86\\x90 Plans \\\\ {plan};\\n19 update plan library (PlanLibrary);\\n20 return true;\\n\\nthe agent has, except for the one that it wants to replace (lines 2\\xe2\\x80\\x933). If we are\\nleft with an empty set of capabilities, then that capability cannot be replaced.\\nOtherwise, the domain is created, translating all capabilities into STRIPS oper-\\nators. Next, we fetch all plans from the agent\\xe2\\x80\\x99s plan library that have the faulty\\ncapability in a plan\\xe2\\x80\\x99s body (line 8).\\n\\nIn lines 9\\xe2\\x80\\x9318 we cycle through each of the plans that include the capability to\\nbe replaced. We construct the initial state from the propagation of the literals\\nfrom the preconditions and postconditions starting at the first capability and\\ngoing up to the last capability before the faulty one in the plan. This propagation\\nis also known as progression in search algorithms. Our Goals set contains the\\npostconditions of the plan to be replaced. We create the problem specification\\nand then call a STRIPS planner to find the replacements by providing the domain\\nand problem specifications that were translated from the Gwendolen syntax.\\nAlthough any STRIPS planner would suffice, we chose the SIW+-then-BFSf\\nplanner [21], one of the faster and top performing planners from the agile track\\nin the International Planning Competition.\\n\\nIf no replacement is found by the planner, then the faulty capability cannot\\nbe replaced in that plan. Otherwise, we swap it with the replacement that was\\nfound (which can contain one or more alternative capabilities), remove the old\\nplan from the temporary plan library, and add in the new plan. After we cycled\\nall plans and replaced the faulty capability within them, the plan library is\\nupdated with the new modifications.\\n\\n\\n\\nPlan Library Reconfigurability in BDI Agents 11\\n\\nA plan in Gwendolen is started by an event, for example, a plan for com-\\npleting a mission mission1 is activated when the goal (!) mission1 is added (+);\\nthis is known as a goal addition event. The plan will be selected and added to\\nthe agent\\xe2\\x80\\x99s intention base if the formulae present in the guard (i.e., the context\\nor precondition of the plan, goes after a colon and between curly brackets) are\\ntrue. After a plan is selected, a sequence of actions in the plan body (denoted\\nby \\xe2\\x86\\x90) is executed.\\n\\n4.1 Practical Experiment\\n\\nWe use a simple problem in our running example of the Mars rover scenario as\\na practical experiment. The problem is to replace a faulty movement capability,\\nmoveW1W2 that represents the route between the topological nodes W1 and\\nW2. For this experiment we focus only on movement capabilities. Although other\\nactions such as collecting rock data are also represented as capabilities, we omit\\nthem since they are not relevant to this experiment.\\n\\nThe capabilities in Figure 2 represent the topological map that the agent\\nhas access to. A precondition list precedes the capability, which is followed by\\na postcondition list. The topological map consists of the following navigation\\nroutes between each waypoint: W1\\xe2\\x87\\x94W2, W1\\xe2\\x87\\x94W3, W3\\xe2\\x87\\x94W2, W1\\xe2\\x87\\x94W4,\\nW2\\xe2\\x87\\x94W5, and W5\\xe2\\x87\\x94W4.\\n\\n1 :Capabilities:\\n2 { at(waypoint1) } moveW1W2 { \\xe2\\x88\\x92at(waypoint1), +at(waypoint2) }\\n3 { at(waypoint2) } moveW2W1 { \\xe2\\x88\\x92at(waypoint2), +at(waypoint1) }\\n4 { at(waypoint1) } moveW1W3 { \\xe2\\x88\\x92at(waypoint1), +at(waypoint3) }\\n5 { at(waypoint3) } moveW3W1 { \\xe2\\x88\\x92at(waypoint3), +at(waypoint1) }\\n6 { at(waypoint3) } moveW3W2 { \\xe2\\x88\\x92at(waypoint3), +at(waypoint2) }\\n7 { at(waypoint2) } moveW2W3 { \\xe2\\x88\\x92at(waypoint2), +at(waypoint3) }\\n8 { at(waypoint1) } moveW1W4 { \\xe2\\x88\\x92at(waypoint1), +at(waypoint4) }\\n9 { at(waypoint4) } moveW4W1 { \\xe2\\x88\\x92at(waypoint4), +at(waypoint1) }\\n\\n10 { at(waypoint2) } moveW2W5 { \\xe2\\x88\\x92at(waypoint2), +at(waypoint5) }\\n11 { at(waypoint5) } moveW5W2 { \\xe2\\x88\\x92at(waypoint5), +at(waypoint2) }\\n12 { at(waypoint5) } moveW5W4 { \\xe2\\x88\\x92at(waypoint5), +at(waypoint4) }\\n13 { at(waypoint4) } moveW4W5 { \\xe2\\x88\\x92at(waypoint4), +at(waypoint5) }\\n\\nFig. 2. Capabilities of the rover agent in Gwendolen.\\n\\nThe plans for the rover agent are listed in Figure 3. There are plans for three\\ndifferent missions, each applicable when the agent is at a different location. For\\nexample, the guard of mission1 (line 3) states that the agent must have the belief\\nat(waypoint1) expressing that the rover must be currently located in waypoint1.\\nThe body of mission1 (lines 5\\xe2\\x80\\x938) contains the capabilities that must be executed\\nin sequential order to successfully achieve the mission\\xe2\\x80\\x99s goal.\\n\\nFigure 4 shows a simple example in the Mars rover scenario using a represen-\\ntation of all the capabilities described in Figure 2. A lander spacecraft stays in its\\noriginal position and acts as a charging station for the rover, which starts next to\\nthe lander at waypoint 1 (W1). At some point during the system\\xe2\\x80\\x99s deployment,\\n\\n\\n\\n12 R. C. Cardoso et al.\\n\\n1 :Plans:\\n2 +!mission1 [perform] :\\n3 { B at (waypoint1) }\\n4 \\xe2\\x86\\x90\\n5 moveW1W2,\\n6 collect soil,\\n7 moveW2W5,\\n8 collect rock;\\n9 +!mission2 [perform] :\\n\\n10 { B at (waypoint4) }\\n11 \\xe2\\x86\\x90\\n12 moveW4W1,\\n13 collect rock,\\n14 moveW1W2,\\n15 take image;\\n16 +!mission3 [perform] :\\n17 { B at (waypoint3) }\\n18 \\xe2\\x86\\x90\\n19 moveW3W1,\\n20 moveW1W2,\\n21 collect rock,\\n22 moveW2W5,\\n23 take image;\\n\\nFig. 3. Plan library of the rover agent in Gwendolen.\\n\\neither while in execution or in the offline period, the capability moveW1W2 is\\ndetected to be faulty. This could have been caused because, for example, the\\nroute between waypoint 1 and waypoint 2 is no longer valid (e.g., there is an\\nunavoidable obstacle), or the route is consuming too much battery (e.g., the\\nterrain became difficult to traverse).\\n\\nL\\nW5 W1 \\n\\nR \\nW2 \\n\\nW3 \\n\\nW4 \\n\\nL = Lander\\nR = Rover\\n\\nW = Waypoint 1..5\\n\\n1 2 3 4 5 \\n\\n1 \\n\\n2 \\n\\n3 \\n\\n4 \\n\\nFig. 4. Mars rover practical example.\\n\\nThe solution found by the planner was to replace the faulty capability\\nmoveW1W2 for moveW1W3 and moveW3W2. Then, we replace all occurrences\\nof that capability in all plans, effectively removing the route between waypoint\\n\\n\\n\\nPlan Library Reconfigurability in BDI Agents 13\\n\\n1 and waypoint 2, and replacing it with the route from waypoint 1 to waypoint\\n3, and then from waypoint 3 to waypoint 2. Although this solves the problem\\ncaused by the faulty capability in all three mission plans, it also introduces some\\nbacktracking in the plan for mission3. This would be necessary if the agent was\\nexecuting that plan and had to stop to reconfigure itself, and then resume from\\nthat moment onward. However, in most other cases it would result in backtrack-\\ning. This illustrates the trade-off between speed and optimality.\\n\\nBecause we are using an agile planner the solution is not always guaran-\\nteed to be optimal. However, as we previously mentioned, the translation from\\nGwendolen can be used in any STRIPS classical planner, including optimal\\nplanners. Another, more advanced, option would be to add reasoning plans to\\nbe able to choose between different planners depending on the situation that the\\nrover is currently in. A simple example of such feature would be to use an agile\\nplanner for generating replacements if the system is running, and an optimal\\nplanner if the system is in offline period.\\n\\n5 Related Work\\n\\nIn [16], an extension of a temporal epistemic logic is used to generalise model\\nchecking as a solution to reconfiguring reactive multi-agent systems. In this case\\nthe problem was to determine whether a set of reactive robots can combine into\\na robot that satisfies the functionality of the system. Two scenarios are given,\\none is a monolithic system and the other is an individual module that is part\\nof a bigger system. They also defined a new logic-based language to represent\\nmulti-agent systems and reason about reconfigurability at an abstract level, but\\nour approach is intended as a generic extension applicable to a range of BDI-\\nbased agent-oriented programming languages and which, as we have shown, can\\nresult directly in an implemented system.\\n\\nAn agent-based framework is proposed for resource reconfiguration in produc-\\ntion lines of industrial assembly applications considering product specification\\nand capabilities of production resources [2]. The reconfiguration is goal-based\\nand done through task reallocation. The authors claim that the framework is\\nimplemented and runs on a real-world assembly system, however, there is no\\nformal description of the framework or any of its features. Although the concept\\nof reconfigurability and capability is similar to ours, the main difference is that\\ntheir concepts are intrinsically tied to industrial assembly applications, whilst\\nour framework is domain independent.\\n\\nAn architecture for planning in reconfigurable manufacturing systems is pre-\\nsented in [4]. Reconfiguration in these systems are described to occur in three\\ndifferent scenarios: a production change, physical malfunctions, or a change in\\nproduction goals. The control system implements a sense-plan-act cycle using\\nontology-based knowledge to regenerate the planning domain specification when\\nnecessary. Similar to the previous approach, this architecture is application spe-\\ncific, and thus, it does not address generic reconfigurability problems.\\n\\n\\n\\n14 R. C. Cardoso et al.\\n\\nA reconfigurable agent-based architecture for use in autonomous nuclear\\nwaste management is reported in [1]. In this system a BDI-agent controls a\\nROS-based system for sorting and segregating different types of low radiation\\nlevel nuclear waste. Reconfiguration is handled by pre-existing plans in the BDI\\nagent rather than by the agent reconfiguring its existing plans. This necessarily\\nlimited the extent to which the system could adapt to hardware degradation and\\nchanges in its environment.\\n\\nThe reconfigurability scenarios that we described could be represented as\\nreplanning problems or plan repair problems [14]. We are particularly interested\\nin applications where a high degree of assurance (ideally formal verification)\\nis required. Formal verification of planning is still an area in its infancy while\\nthe verification of BDI agents is well studied \\xe2\\x80\\x94 hence we have developed a\\nframework in which planning is used to instantiate new replacement plans2 in\\nBDI programming languages. Furthermore the complete state of the world would\\nhave to be passed to a planner. By using our reconfigurability framework this\\ncan be avoided, potentially saving computation time.\\n\\n6 Conclusions\\n\\nThere are different ways that the reconfigurability problem can be solved, such\\nas: preemptively adding plans that cover plan failure; or replanning from scratch.\\nHowever, the former is prone to human error, and the latter can take substan-\\ntially longer in complex problems.\\n\\nIn this paper, we have described a formal framework for plan library reconfig-\\nurability in BDI agents. We presented a theory based on capabilities and plans,\\nand introduced several definitions concerning how to reason about valid plan re-\\nplacement. Further to this, we implemented our framework into the Gwendolen\\nBDI language and used an agile planner to find capability replacements that are\\nthen merged into a plan replacement. As a demonstration of the implementation\\nof our framework we performed a practical experiment on reconfigurability in\\nthe Mars rover scenario.\\n\\nThe performance of the implementation our reconfigurability framework is\\nintrinsically tied to the performance of the planner\\xe2\\x80\\x99s implementation that we\\nused to find the proper replacements for a faulty capability. Therefore, future\\nexperiments to measure the scalability of our framework should include differ-\\nent planners to better evaluate how well our approach scales by isolating the\\nperformance of the planning component. Future work also include considering\\nplan regression to rationally discard redundant capabilities that came before the\\nfaulty capability to remove any unnecessary backtracking.\\n\\n2 The areas of automated planning and BDI agent programming both use the word\\n\\xe2\\x80\\x9cplan\\xe2\\x80\\x9d but with slightly different meanings.\\n\\n\\n\\nPlan Library Reconfigurability in BDI Agents 15\\n\\nReferences\\n\\n1. Aitken, J.M., Veres, S.M., Shaukat, A., Gao, Y., Cucco, E., Dennis, L.A., Fisher,\\nM., Kuo, J.A., Robinson, T., Mort, P.E.: Autonomous nuclear waste management.\\nIEEE Intelligent Systems 33(6), 47\\xe2\\x80\\x9355 (Nov 2018)\\n\\n2. Antzoulatos, N., Castro, E., de Silva, L., Rocha, A.D., Ratchev, S., Barata, J.: A\\nmulti-agent framework for capability-based reconfiguration of industrial assembly\\nsystems. International Journal of Production Research 55(10), 2950\\xe2\\x80\\x932960 (2017)\\n\\n3. Bogue, R.: Robots in the nuclear industry: a review of technologies and applica-\\ntions. Industrial Robot: An International Journal 38(2), 113\\xe2\\x80\\x93118 (2011)\\n\\n4. Borgo, S., Cesta, A., Orlandini, A., Umbrico, A.: A planning-based architecture\\nfor a reconfigurable manufacturing system. In: Proceedings of the Twenty-Sixth\\nInternational Conference on International Conference on Automated Planning and\\nScheduling. pp. 358\\xe2\\x80\\x93366. ICAPS\\xe2\\x80\\x9916, AAAI Press, London, UK (2016)\\n\\n5. Chen, I.M., Yang, G., Yeo, S.H.: Automatic modeling for modular reconfigurable\\nrobotic systems: Theory and practice. In: Cubero, S. (ed.) Industrial Robotics,\\nchap. 2. IntechOpen, Rijeka (2006)\\n\\n6. Dennis, L.A., Farwer, B.: Gwendolen: A BDI language for verifiable agents. In:\\nLogic and the Simulation of Interaction and Reasoning. AISB, Aberdeen (2008)\\n\\n7. Dennis, L.A., Fisher, M.: Actions with durations and failures in BDI languages.\\nIn: 21st European Conference on Artificial Intelligence. vol. 263, pp. 995\\xe2\\x80\\x93996. IOS\\nPress (2014)\\n\\n8. Dennis, L.A., Fisher, M., Aitken, J.M., Veres, S.M., Gao, Y., Shaukat, A., Bur-\\nroughes, G.: Reconfigurable autonomy. KI - Ku\\xcc\\x88nstliche Intelligenz 28(3), 199\\xe2\\x80\\x93207\\n(Aug 2014)\\n\\n9. Dennis, L.A., Fisher, M., Webster, M.P., Bordini, R.H.: Model checking agent\\nprogramming languages. Automated Software Engineering 19(1), 5\\xe2\\x80\\x9363 (2012)\\n\\n10. Farrell, M., Luckcuck, M., Fisher, M.: Robotics and integrated formal methods:\\nNecessity meets opportunity. In: International Conference on Integrated Formal\\nMethods. pp. 161\\xe2\\x80\\x93171. Springer (2018)\\n\\n11. Ferrando, A., Dennis, L.A., Ancona, D., Fisher, M., Mascardi, V.: Verifying and\\nvalidating autonomous systems: Towards an integrated approach. In: Proceedings\\nof the 18th International Conference on Runtime Verification. Lecture Notes in\\nComputer Science, vol. 11237, pp. 263\\xe2\\x80\\x93281. Springer (2018)\\n\\n12. Fikes, R.E., Nilsson, N.J.: STRIPS: A new approach to the application of theorem\\nproving to problem solving. Artificial Intelligence 2(3), 189 \\xe2\\x80\\x93 208 (1971)\\n\\n13. Flores-Abad, A., Ma, O., Pham, K., Ulrich, S.: A review of space robotics tech-\\nnologies for on-orbit servicing. Progress in Aerospace Sciences 68, 1\\xe2\\x80\\x9326 (2014)\\n\\n14. Fox, M., Gerevini, A., Long, D., Serina, I.: Plan stability: Replanning versus plan\\nrepair. In: Proceedings of the 16th International Conference on Automated Plan-\\nning and Scheduling. pp. 212\\xe2\\x80\\x93221. AAAI Press, Cumbria, UK (2006)\\n\\n15. Hawes, N., Burbridge, C., Jovan, F., Kunze, L., Lacerda, B., Mudrova, L., Young,\\nJ., Wyatt, J., Hebesberger, D., Kortner, T., Ambrus, R., Bore, N., Folkesson,\\nJ., Jensfelt, P., Beyer, L., Hermans, A., Leibe, B., Aldoma, A., Faulhammer, T.,\\nZillich, M., Vincze, M., Chinellato, E., Al-Omari, M., Duckworth, P., Gatsoulis,\\nY., Hogg, D.C., Cohn, A.G., Dondrup, C., Fentanes, J.P., Krajnik, T., Santos,\\nJ.M., Duckett, T., Hanheide, M.: The STRANDS project: Long-term autonomy in\\neveryday environments. Robotics Automation Magazine 24(3), 146\\xe2\\x80\\x93156 (2017)\\n\\n16. Huang, X., Chen, Q., Meng, J., Su, K.: Reconfigurability in reactive multiagent\\nsystems. In: Proceedings of the 25th International Joint Conference on Artificial\\nIntelligence. pp. 315\\xe2\\x80\\x93321. AAAI Press, New York, USA (2016)\\n\\n\\n\\n16 R. C. Cardoso et al.\\n\\n17. Kohn, W., Nerode, A.: Multiple agent autonomous hybrid control systems. In:\\nProc. 31st Conf. Decision and Control (CDC). pp. 2956\\xe2\\x80\\x932964. Tucson, USA (1992)\\n\\n18. Koren, Y., Heisel, U., Jovane, F., Moriwaki, T., Pritschow, G., Ulsoy, G., Brussel,\\nH.V.: Reconfigurable manufacturing systems. CIRP Annals 48(2), 527\\xe2\\x80\\x93540 (1999)\\n\\n19. Kruijff-Korbayova\\xcc\\x81, I., Colas, F., Gianni, M., Pirri, F., de Greeff, J., Hindriks, K.,\\nNeerincx, M., O\\xcc\\x88gren, P., Svoboda, T., Worst, R.: TRADR Project: Long-term\\nhuman-robot teaming for robot assisted disaster response. KI - Ku\\xcc\\x88nstliche Intelli-\\ngenz 29(2), 193\\xe2\\x80\\x93201 (Jun 2015)\\n\\n20. Leita\\xcc\\x83o, P.: Agent-based distributed manufacturing control: A state-of-the-art sur-\\nvey. Engineering Applications of Artificial Intelligence 22(7), 979\\xe2\\x80\\x93991 (2009)\\n\\n21. Lipovetzky, N., Ramirez, M., Muise, C., Geffner, H.: Width and inference based\\nplanners: SIW, BFS (f), and PROBE. In: Proceedings of the 8th International\\nPlanning Competition (2014)\\n\\n22. Marik, V., McFarlane, D.: Industrial adoption of agent-based technologies. IEEE\\nIntelligent Systems 20(1), 27\\xe2\\x80\\x9335 (Jan 2005)\\n\\n23. Mcdermott, D., Ghallab, M., Howe, A., Knoblock, C., Ram, A., Veloso, M., Weld,\\nD., Wilkins, D.: PDDL - the planning domain definition language. Tech. Rep.\\nTR-98-003, Yale Center for Computational Vision and Control (1998)\\n\\n24. Murphy, R.R.: Trial by fire [rescue robots]. IEEE Robotics Automation Magazine\\n11(3), 50\\xe2\\x80\\x9361 (Sept 2004)\\n\\n25. Muscettola, N., Nayak, P.P., Pell, B., Williams, B.: Remote agent: To boldly go\\nwhere no AI system has gone before. Artificial Intelligence 103(1-2), 5\\xe2\\x80\\x9348 (1998)\\n\\n26. Quigley, M., Conley, K., Gerkey, B., Faust, J., Foote, T., Leibs, J., Wheeler, R., Ng,\\nA.: ROS: an open-source robot operating system. In: Workshop on Open Source\\nSoftware at the International Conference on Robotics and Automation. IEEE,\\nJapan (2009)\\n\\n27. Rao, A.S., Georgeff, M.P.: BDI agents: From theory to practice. In: Proceedings\\nof the first International Conference on Multi-Agent Systems. pp. 312\\xe2\\x80\\x93319 (1995)\\n\\n28. Reiter, R.: The frame problem in situation the calculus: A simple solution (some-\\ntimes) and a completeness result for goal regression. In: Lifschitz, V. (ed.) Artificial\\nIntelligence and Mathematical Theory of Computation, pp. 359\\xe2\\x80\\x93380. Academic\\nPress Professional, Inc., San Diego, CA, USA (1991)\\n\\n29. Shukla, A., Karki, H.: Application of robotics in offshore oil and gas industry \\xe2\\x80\\x93 A\\nreview Part II. Robotics and Autonomous Systems 75, 508\\xe2\\x80\\x93524 (2016)\\n\\n30. Singh, B., Sellappan, N., P., K.: Evolution of industrial robots and their applica-\\ntions. International Journal of Emerging Technology and Advanced Engineering\\n3(5), 763\\xe2\\x80\\x93768 (May 2013)\\n\\n31. St\\xc3\\xb8y, K., Brandt, D., Christensen, D.J.: Self-Reconfigurable Robots. MIT Press\\n(2010)\\n\\n32. Tate, A.: Generating project networks. In: Proceedings of the 5th International\\nJoint Conference on Artificial Intelligence - Volume 2. pp. 888\\xe2\\x80\\x93893. IJCAI\\xe2\\x80\\x9977, Mor-\\ngan Kaufmann Publishers Inc., San Francisco, CA, USA (1977)\\n\\n33. Webster, M.P., Fisher, M., Cameron, N., Jump, M.: Formal methods for the cer-\\ntification of autonomous unmanned aircraft systems. In: Proc. 30th Int. Conf.\\nComputer Safety, Reliability and Security. LNCS, vol. 6894, pp. 228\\xe2\\x80\\x93242. Springer\\n(2011)\\n\\n34. Wei, C., Hindriks, K.V.: An agent-based cognitive robot architecture. In: Program-\\nming Multi-Agent Systems, LNCS, vol. 7837, pp. 54\\xe2\\x80\\x9371. Springer (2013)\\n\\n35. Wilcox, B.H.: Robotic vehicles for planetary exploration. Applied Intelligence 2(2),\\n181\\xe2\\x80\\x93193 (1992)\\n\\n\\n\\tPlan Library Reconfigurability in BDI Agents\\n\\n'