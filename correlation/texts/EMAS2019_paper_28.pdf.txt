b'\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nConcurrency and Asynchrony in Protocol\\nLanguages\\n\\nAmit K. Chopra1, Samuel H. Christie V2, and Munindar P. Singh3\\n\\n1 Lancaster University amit.chopra@lancaster.ac.uk\\n2 Lancaster University s.christie@lancaster.ac.uk\\n3 North Carolina State University singh@ncsu.edu\\n\\nAbstract. Despite shared objectives, modern languages for specifying\\nmultiagent interaction protocols differ significantly in their\\xe2\\x80\\x94often complex\\xe2\\x80\\x94\\ntechnical details. We contribute a comparative evaluation of prominent\\nselect languages based on their support for concurrent enactments and\\nfor asynchrony, both important facets of flexibility. We show how the\\nunderlying abstractions and assumptions of the various languages fare\\non these criteria.\\n\\n1 Introduction\\n\\nProtocols lie at the heart of multiagent systems (MAS). Specification languages\\nfor protocols are therefore crucial in engineering MAS. Several notable MAS\\nsoftware methodologies, e.g., [11,4,12], give a place of prominence to specify-\\ning protocols; however, most rely on informal notations such as AUML [10] for\\nspecifying them.\\n\\nOver the last two decades, several formal languages for specifying protocols\\nhave been proposed, and in communities as diverse as programming languages,\\nWeb services, and multiagent systems. These languages make different assump-\\ntions and provide varying capabilities for specifying protocols. However, today,\\nwe lack generally clear evaluation criteria or use cases for protocol languages.\\nAny set of evaluation criteria would necessarily be incomplete, but what would\\nconstitute an informative set that sheds light upon the theoretical foundations\\nfor protocols? To answer this question, we turn to some central challenges in\\nspecifying interaction protocols.\\n\\nA central challenge in specifying interaction protocols for MAS is how to\\nenable the specification of flexible protocols that agents can correctly enact in\\na decentralized manner, that is, based solely only on local knowledge and ac-\\ncommodating asynchrony? This challenge captures the essence of what drives\\nmost theoretical work on protocol languages [3,7,2,15,5,9]. The difficulty is that\\nflexibility, which includes important aspects such as concurrency, is in tension\\nwith correctness in asynchronous settings.\\n\\nBased on the foregoing, we motivate the following criteria for evaluating\\nprotocol languages. How well does a language support concurrent enactments?\\nHow well does a language support asynchrony? For example, does it require\\nordered delivery of messages?\\n\\nlouisedennis\\nPlaced Image\\n\\n\\n\\n2 Chopra et al.\\n\\nUsing these criteria, we undertake a comparative evaluation of selected ap-\\nproaches. We focus on state-of-the-art languages. Specifically, we evaluate each\\napproach with respect to the same criteria by specifying (as best possible) the\\nsame scenarios.\\n\\nThe paper\\xe2\\x80\\x99s overarching contribution and significance lie in developing and\\napplying unified evaluation criteria for protocol languages. Its novelty arises\\nfrom the absence, currently, of such a framework. Notably, this paper focuses\\non essential representational criteria and plays down contingent features such as\\ncurrent tool support and popularity.\\n\\n2 Overview of Selected Approaches\\n\\nWe select protocol specification languages that are recent and represent diverse\\ndoctrines. We introduce their main ideas via a common scenario in which a\\nbuyer B requests an item from a seller S, who responds with a price. B may\\naccept or reject the offer. Rejection ends the enactment. If B accepts, S instructs\\nwarehouse W to ship the item, following which W delivers it to B.\\n\\n.\\n\\n2.1 Multiparty Session Types\\n\\nWe discuss two prominent approaches, Trace and Scribble.\\n\\nTrace Expressions. Castagna et al. [5], Ancona et al. [1], and Ferrando et al.\\n[8] exemplify this approach. Hereon, we refer to this approach as Trace. We\\nfollow Castagna et al.\\xe2\\x80\\x99s [5] variant for concreteness as they give clear rules for\\ndetermining projections of protocols. Here, x m\\xe2\\x88\\x92\\xe2\\x86\\x92y means that x sends message m\\nto y; \\xe2\\x80\\x98;\\xe2\\x80\\x99 denotes sequence, \\xe2\\x80\\x98\\xe2\\x88\\xa8\\xe2\\x80\\x99 denotes mutually exclusive choice, and \\xe2\\x80\\x98\\xe2\\x88\\xa7\\xe2\\x80\\x99 denotes\\nshuffle (order-preserving interleaving). Trace assumes pairwise-FIFO communi-\\ncation. Listing 1 shows how our purchase example may be rendered in Trace.\\n\\nListing 1: Three-party Purchase protocol in Trace.\\n\\nB Item\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92 S ; S Price\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92 B ;\\n(B Accept\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92 S ; S Ship\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92 W ; W Deliver\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92 B) \\xe2\\x88\\xa8 B Reject\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92 S\\n\\nGiven a protocol, Trace yields projections for each role. A role\\xe2\\x80\\x99s projection\\nrepresents the local protocol-related computations performed by the role. Ideally,\\nthe computations realized jointly by all projections of a protocol should exactly\\nbe the computations of the protocol (as we shall see, this is not always the case).\\n\\nScribble. Scribble [19] (which is itself based on [9]) is similar to Trace. A proto-\\ncol is an ordering of constituent protocols (bottoming out at individual message\\nspecifications) using constructs such as sequence, choice, and iteration. Scrib-\\nble assumes ordered communication over FIFO channels. Listing 2 highlights its\\nsalient features.\\n\\n\\n\\nConcurrency and Asynchrony in Protocol Languages 3\\n\\nListing 2: Three-party Purchase in Scribble.\\n\\np r o t o c o l Purchase ( r o l e B, r o l e S , r o l e W) {\\nI tem ( s t r i n g ) from B to S ;\\nP r i c e ( i n t ) from S to B ;\\n\\nc h o i c e a t B {\\nAccept ( ) from B to S ;\\nSh ip ( ) from S to W;\\nD e l i v e r ( ) from W to B ;\\n} o r {\\n\\nR e j e c t ( ) from B to S ;\\nNoShip ( ) from S to W; }}\\n\\nScribble [14] has tooling that can generate role-specific projections from pro-\\ntocols.\\n\\n2.2 HAPN\\n\\nHAPN [17] is a graphical protocol language. As Figure 1 shows, nodes repre-\\nsent states; they can also reference other protocols to compose them. Edges can\\nhave complex annotations, supporting the specification of message transmissions,\\nguard expressions, and changes to state. HAPN specifies the computations of a\\nprotocol in terms of state machines. It assumes synchronous communication [17,\\np. 61] and does not give a method for projecting a protocol to local perspectives\\n(although it acknowledges their need).\\n\\ns0 s1 s2 s3\\n\\nB 7\\xe2\\x86\\x92 S:\\nAccept()\\n\\ns5\\n\\ns6\\n\\nW 7\\xe2\\x86\\x92 B: Deliver()\\n\\nS 7\\xe2\\x86\\x92 W:\\nShip()\\n\\ns4\\n\\nB 7\\xe2\\x86\\x92 S: Reject()\\n\\nS 7\\xe2\\x86\\x92 B:\\nPrice()\\n\\nB 7\\xe2\\x86\\x92 S:\\nItem()\\n\\nP:\\n\\nFig. 1: Three-party Purchase in HAPN, starting from s0.\\n\\nHAPN provides methods to flatten a hierarchical protocol into simple proto-\\ncols and finite state machines for verification.\\n\\n2.3 BSPL\\n\\nBSPL [15,16] and Splee [6], which extends BSPL, are exemplars of information-\\nbased languages, which are declarative and eschew specifying ordering between\\nmessages. In BSPL, a protocol specifies an information object. Each protocol\\nenactment fills out an instance of this object. A protocol specifies two kinds of\\nconstraints on the messages a role can observe: causality or information flow\\nconstraints between protocols and integrity or consistency constraints on any\\nobject.\\n\\n\\n\\n4 Chopra et al.\\n\\nListing 3: Three-party Purchase in BSPL.\\n\\nPurchase {\\nrole B, S , W\\nparameter out ID key , out item , out p r i c e , out d , out OK\\n\\nB 7\\xe2\\x86\\x92 S : RFQ[ out ID , out i tem ]\\nS 7\\xe2\\x86\\x92 B : O f f e r [ i n ID , i n item , out p r i c e ]\\nB 7\\xe2\\x86\\x92 S : Accept [ i n ID , i n item , i n p r i c e , out d , out addr ]\\nB 7\\xe2\\x86\\x92 S : R e j e c t [ i n ID , i n p r i c e , out d , out OK]\\nS 7\\xe2\\x86\\x92 W: Ship [ i n ID , i n item , i n addr ]\\nW 7\\xe2\\x86\\x92 B : D e l i v e r [ i n ID , i n item , i n addr , out OK] }\\n\\nIn Listing 3, B requests a quote from S for a specific item, and initiates\\nan enactment uniquely identified by key ID. The poutq annotations on ID and\\nitem mean that in sending RFQ, B produces bindings for those parameters. The\\npinq annotations on ID and item in the Offer message indicate that S needs to\\nknow these parameters before S can send Offer. B can either accept or reject\\nthe offered price, but not both, because both messages produce a \\xe2\\x80\\x9cdecision\\xe2\\x80\\x9d (as\\nd), and integrity requires a parameter to have at most one binding. An accept\\nmessage includes the buyer\\xe2\\x80\\x99s address, so S can send shipping instructions to\\nwarehouse W. An enactment is complete when all public poutq parameters are\\nbound, so either Reject or Deliver can complete Purchase. Notice that S cannot\\nsend Ship if Reject happens as it does not know addr.\\n\\nThe projection of a BSPL protocol to a role is a protocol containing only\\nthose messages that involve the specified role. For example, the projection of\\nPurchase for W consists only of Ship and Deliver.\\n\\n3 Concurrent Enactments\\n\\nTo support autonomy, we should constrain an agent only as essential to the\\nenactment of a protocol. In particular, we should allow agents to act concurrently\\nwhen doing so would not violate correctness.\\n\\nScenario. B sends Request to S to ship some item. After sending Request,\\nB may send Payment. After receiving Request, S may send Shipment. That is,\\nPayment and Shipment are not mutually ordered.\\n\\nThis scenario is natural in case of reciprocal commitments: B commits to S\\nthat if Shipment occurs, B will send a Payment and S commits to B that if\\nPayment occurs, S will send a Shipment [18].\\n\\nFigure 2 shows possible enactments of one protocol instance, eliding the\\nparameters.\\n\\nListing 4 gives a Trace protocol specification that appears to capture the\\nscenario.\\n\\nListing 4: Attempt to capture Figure 2 in Trace.\\n\\nB Request\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92 S ; (B Payment\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92 S \\xe2\\x88\\xa7 S Shipment\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92 B)\\n\\n\\n\\nConcurrency and Asynchrony in Protocol Languages 5\\n\\nB S\\n\\nRequest\\n\\nShipment\\n\\nPayment\\n\\n(a) Shipment first.\\n\\nB S\\n\\nRequest\\nPayment\\n\\nShipment\\n\\n(b) Payment first.\\n\\nB S\\n\\nRequest\\nPayment\\n\\nShipme\\nnt\\n\\n(c) Concurrent.\\n\\nFig. 2: Three possible enactments of Purchase.\\n\\nThe shortcomings of Listing 4 become apparent when determining its pro-\\njections. Following Trace [5, p. 14], we eliminate \\xe2\\x88\\xa7 from Listing 4 to obtain the\\nequivalent Listing 5.\\n\\nListing 5: A Trace transformation of protocol in Listing 4.\\n\\nB Request\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92 S ; (B Payment\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92 S ; S Shipment\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92 B) \\xe2\\x88\\xa8 ( S Shipment\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92 B ; B Payment\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92 S )\\n\\nListing 5 is unprojectable because the choice is controlled by different parties\\xe2\\x80\\x94\\neither B pays or S ships. Specifically, the projections must interpret \\xe2\\x88\\xa8 as external\\nchoice (choosing) for one agent and an internal choice (following) for another.\\nListing 6 arbitrarily gives the external choice (denoted +) to B and the inter-\\nnal choice (denoted \\xe2\\x8a\\x95) to S (the reverse is equally good since the situation is\\nsymmetric). However, this provides only the illusion of choice, because choosing\\nto receive causes deadlock; the agent arbitrarily given the internal choice must\\nsend first, enabling only one of the two desired enactments.\\n\\nListing 6: Hypothetical local projections in Trace that illustrate the difficulty\\nwith choice.\\n\\nB : S ! Request . ( S? Shipment . S ! Payment ) + ( S ! Payment . S? Shipment )\\nS : B? Request . ( B! Shipment . B? Payment ) \\xe2\\x8a\\x95 (B? Payment . B! Shipment )\\n\\nCastagna et al. formalize properties of sequentiality and knowledge for choice\\nunder which Listing 6 is invalid because of the nonlocal choice between Payment\\nand Shipment.\\n\\nScribble shares Trace\\xe2\\x80\\x99s limitations. Listing 7 shows how we might model the\\nscenario in Scribble. Scribble tooling rejects the protocol as ill-formed because\\nthe choice is at B but one of the alternatives triggers with an action by S.\\n\\nListing 7: Encode in Scribble.\\n\\np r o t o c o l F l e x i b l e P u r c h a s e ( r o l e B, r o l e S ) {\\nRequest ( ) from B to S ;\\nc h o i c e a t B {\\n\\nPayment ( ) from B to S ;\\nShipment ( ) from S to B ;\\n\\n} o r {\\nShipment ( ) from S to B ; // not v a l i d\\nPayment ( ) from B to S ;}}\\n\\n\\n\\n6 Chopra et al.\\n\\nFigure 3\\xe2\\x80\\x99s HAPN protocol captures only the first two enactments, not the\\nconcurrent one, because HAPN assumes synchrony.\\n\\ns0 s1 s2\\nB 7\\xe2\\x86\\x92 S: Request()\\n\\nB 7\\xe2\\x86\\x92 S: Payment()[unbound(paid)]/bind(paid,T)\\n\\nS 7\\xe2\\x86\\x92 B: Shipment()[unbound(shipped)]/bind(shipped,T)\\n\\n[bound(paid)\\xe2\\x88\\xa7bound(shipped)]\\nP:\\n\\nFig. 3: FlexiblePurchase in HAPN.\\n\\nListing 8 gives a BSPL protocol. It supports the enactment in Figure 2c\\nbecause after B sends Request, it has the information needed to send Payment\\nand, upon receiving Request, S has the information needed to send Shipment.\\n\\nListing 8: A protocol exhibiting concurrency.\\n\\nF l e x i b l e Purchase {\\nrole B, S\\nparameter out ID key , out item , out sh ipped , out p a i d\\n\\nB 7\\xe2\\x86\\x92 S : Request [ out ID , out i tem ]\\nS 7\\xe2\\x86\\x92 B : Shipment [ i n ID , i n item , out s h i p p e d ]\\nB 7\\xe2\\x86\\x92 S : Payment [ i n ID , i n item , out p a i d ] }\\n\\n4 Asynchrony\\nWhereas synchronous communication couples a sender and receiver (they must\\nbe ready to receive and send at the same time), asynchronous communication\\ndoes not. Asynchrony is supported by the Internet and promotes decentraliza-\\ntion: agents do not need to know of each other\\xe2\\x80\\x99s states or wait for each other.\\nScribble, Trace, and BSPL support asynchrony; HAPN [17, p. 61] does not.\\nHowever, digging deeper, we uncover significant differences between Scribble\\nand Trace on the one hand and BSPL on the other. The differences stem from\\nthe fact that Scribble and Trace both require pairwise-FIFO delivery of messages\\nwhereas BSPL does not.\\n\\nA consequence of the end-to-end principle [13] is that a protocol should not\\nrely on message ordering guarantees from the communication infrastructure since\\nthe appropriate constraints are to be checked in an upper layer. Relying on such\\nguarantees naturally limits the kinds of communication infrastructures upon\\nwhich a protocol may be used. Further, protocols for lightweight communications\\n(e.g., for IoT) or fast interactions (e.g., in financial transactions) cannot support\\nFIFO. And, FIFO is inadequate for settings of more than two parties as the\\nfollowing scenario demonstrates.\\n\\nScenario. In an indirect-payment purchase protocol, after receiving an Offer\\nB sends Accept to S and then Instruct (a payment instruction) to bank K. Upon\\nreceiving Instruct, K does a funds Transfer to S.\\n\\n\\n\\nConcurrency and Asynchrony in Protocol Languages 7\\n\\nB S K\\n\\nOffer\\n\\nAccept Instruct\\n\\nTransfe\\nr\\n\\n(a) In-order delivery.\\n\\nB S K\\n\\nOffer\\n\\nAccept\\n\\nInstruct\\n\\nTransfe\\nr\\n\\n(b) Out-of-order delivery.\\n\\nFig. 4: FIFO does not guarantee stable ordering.\\n\\nFigure 4 shows two enactments for this scenario. In Figure 4a, S receives\\nAccept before Transfer whereas in Figure 4b, S receives it after Transfer. Both\\nenactments satisfy pairwise FIFO. The enactments illustrate that even with\\nFIFO ordering, asynchrony makes ordering indeterminate for protocols involving\\nmore than two agents. Listing 9 gives a protocol that supports both enactments\\nin Figure 4.\\n\\nListing 9: Indirect payment protocol in BSPL.\\n\\nI n d i r e c t Payment {\\nrole B, S , K // K i s bank\\nparameter out ID key , out item , out p r i c e , out acc , out i n s t ,\\n\\nout OK\\n\\nS 7\\xe2\\x86\\x92 B : O f f e r [ out ID , out item , out p r i c e ]\\nB 7\\xe2\\x86\\x92 S : Accept [ i n ID , i n item , i n p r i c e , out acc ]\\nB 7\\xe2\\x86\\x92 K: I n s t r u c t [ i n ID , i n p r i c e , i n acc , out i n s t ]\\nK 7\\xe2\\x86\\x92 S : T r a n s f e r [ i n ID , i n p r i c e , i n i n s t , out OK] }\\n\\nListing 10 is an attempt to capture the scenario in Trace. Following Trace\\n[5, p. 16], this protocol is not well-formed, which means that the correctness of\\nits projections, also given in Listing 10, cannot be guaranteed. Specifically, the\\nprojection for S expects Accept before Transfer and therefore does not support\\nthe enactment in Figure 4b, which may arise despite using FIFO channels.\\n\\nListing 10: A plausible indirect payment protocol and its projections in Trace.\\n\\n// P r o t o c o l\\n\\nS Offer\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92 B ; B Accept\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92 S ; B Instruct\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92 K; K Transfer\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x88\\x92\\xe2\\x86\\x92 S\\n// P r o j e c t i o n s\\nB : S? O f f e r . S ! Accept .K! I n s t r u c t\\nS : B! O f f e r . B? Accept .K? T r a n s f e r\\nK: B? I n s t r u c t . S ! T r a n s f e r\\n\\nListing 11 gives a Scribble protocol to capture the scenario. The projections\\ngiven are produced by Scribble tooling, which verifies the specification. The\\nprojections are analogous to the Trace projections in Listing 10; in particular, S\\ncannot receive Transfer before Accept; it blocks on the reception of Accept on\\nthe channel from B even if Transfer may have arrive earlier on the channel from\\n\\n\\n\\n8 Chopra et al.\\n\\nK. Effectively, the projection reorders the receptions of the two messages. The\\nlisting shows S\\xe2\\x80\\x99s projection (other roles\\xe2\\x80\\x99 projections are elided).\\n\\nListing 11: Indirect payment in Scribble.\\n\\np r o t o c o l I n d i r e c t P a y m e n t ( r o l e S , r o l e C , r o l e B) {\\nO f f e r ( ) from S to B ;\\nAccept ( ) from B to S ;\\nI n s t r u c t ( ) from B to K;\\nT r a n s f e r ( ) from K to S ; }\\n\\np r o j e c t i o n I n d i r e c t P a y m e n t S ( r o l e B, r o l e S , r o l e K) {\\nO f f e r ( ) to B ;\\nAccept ( ) from B ;\\nT r a n s f e r ( ) from K; }\\n\\nReordering messages as Scribble does undesirable for many reasons. One,\\nprocessing of messages that have arrived earlier is unnecessarily delayed. Two,\\nblocking paves the way for deadlocks. For example, imagine a scenario where an\\nagent is waiting for m1 to arrive, with m2 already in its buffer waiting to be\\nreceived by the agent. If m2 disables the emission of m1, then the agent is dead-\\nlocked. What the foregoing scenario shows is that despite the FIFO assumption,\\nboth Scribble and Trace (unnecessarily) rule out realistic message orders that\\nare simply the result of asynchrony.\\n\\n5 Summary\\n\\nTable 1: Summary of evaluation.\\n\\nCriterion Scribble Trace HAPN BSPL\\n\\nConcurrency No No No Yes\\nAsynchrony Yes Yes No Yes\\nUnordering No No \\xe2\\x80\\x93 Yes\\n\\nTable 1 summarizes our findings. Our criteria and scenarios are elementary,\\nmotivated from fundamental challenges for interaction protocols. And our se-\\nlected approaches represent recent research into protocols. Our evaluation is\\nconcrete and comparative, driven by the specification of scenarios in the se-\\nlected approaches, followed by their analysis. Our evaluation shows significant\\nadvantages of BSPL over the other approaches. The results presented here can\\nbe a starting point for a more extensive comparison of protocol languages.\\n\\nAcknowledgments. We thank the reviewers for providing useful comments.\\nChopra and Christie were supported by EPSRC grant EP/N027965/1 (Turtles).\\nSingh thanks the US Department of Defense for partial support under the Science\\nof Security Lablet.\\n\\n\\n\\nConcurrency and Asynchrony in Protocol Languages 9\\n\\nReferences\\n\\n1. Ancona, D., Ferrando, A., Franceschini, L., Mascardi, V.: Coping with bad agent\\ninteraction protocols when monitoring partially observable multiagent systems.\\nIn: Proceedings of the 16th International Conference on Advances in Practical\\nApplications of Agents, Multi-Agent Systems, and Complexity (PAAMS). Lecture\\nNotes in Computer Science, vol. 10978, pp. 59\\xe2\\x80\\x9371. Springer, Toledo, Spain (Jun\\n2018)\\n\\n2. Baldoni, M., Baroglio, C., Chopra, A.K., Desai, N., Patti, V., Singh, M.P.: Choice,\\ninteroperability, and conformance in interaction protocols and service choreogra-\\nphies. In: Proceedings of the 9th International Conference on Autonomous Agents\\nand Multiagent Systems. pp. 843\\xe2\\x80\\x93850. IFAAMAS, Budapest (2009)\\n\\n3. Baldoni, M., Baroglio, C., Martelli, A., Patti, V.: A priori conformance verification\\nfor guaranteeing interoperability in open environments. In: Proceedings of the 4th\\nInternational Conference on Service-Oriented Computing (ICSOC). Lecture Notes\\nin Computer Science, vol. 4294, pp. 339\\xe2\\x80\\x93351. Springer, Chicago (2006)\\n\\n4. Bresciani, P., Perini, A., Giorgini, P., Giunchiglia, F., Mylopoulos, J.: Tropos: An\\nagent-oriented software development methodology. Autonomous Agents and Multi-\\nAgent Systems 8(3), 203\\xe2\\x80\\x93236 (2004)\\n\\n5. Castagna, G., Dezani-Ciancaglini, M., Padovani, L.: On global types and multi-\\nparty sessions. Logical Methods in Computer Science 8(1), 1\\xe2\\x80\\x9345 (Mar 2012)\\n\\n6. Chopra, A.K., Christie V, S.H., Singh, M.P.: Splee: A declarative information-based\\nlanguage for multiagent interaction protocols. In: Proceedings of the 16th Inter-\\nnational Conference on Autonomous Agents and MultiAgent Systems (AAMAS).\\npp. 1054\\xe2\\x80\\x931063. IFAAMAS, Sa\\xcc\\x83o Paulo (May 2017)\\n\\n7. Desai, N., Singh, M.P.: On the enactability of business protocols. In: Proceedings\\nof the 23rd Conference on Artificial Intelligence (AAAI). pp. 1126\\xe2\\x80\\x931131. AAAI\\nPress, Menlo Park (Jul 2008)\\n\\n8. Ferrando, A., Ancona, D., Mascardi, V.: Decentralizing MAS monitoring with\\nDecAMon. In: Proceedings of the 16th International Conference on Autonomous\\nAgents and MultiAgent Systems (AAMAS). pp. 239\\xe2\\x80\\x93248. IFAAMAS, Sa\\xcc\\x83o Paulo\\n(May 2017)\\n\\n9. Honda, K., Yoshida, N., Carbone, M.: Multiparty asynchronous session types. Jour-\\nnal of the ACM 63(1), 9:1\\xe2\\x80\\x939:67 (2016)\\n\\n10. Odell, J.J., Parunak, H.V.D., Bauer, B.: Representing agent interaction protocols\\nin UML. In: Agent-Oriented Software Engineering. Lecture Notes in Computer\\nScience, vol. 1957, pp. 201\\xe2\\x80\\x93218. Springer (2001)\\n\\n11. Omicini, A.: SODA: societies and infrastructures in the analysis and design of\\nagent-based systems. In: Proceedings of the International Workshop on Agent-\\nOriented Software Engineering. LNCS, vol. 1957, pp. 185\\xe2\\x80\\x93193. Springer (2000)\\n\\n12. Padgham, L., Winikoff, M.: Prometheus: A practical agent-oriented methodol-\\nogy. In: Henderson-Sellers, B., Giorgini, P. (eds.) Agent-Oriented Methodologies,\\nchap. 5, pp. 107\\xe2\\x80\\x93135. Idea Group, Hershey, PA (2005)\\n\\n13. Saltzer, J.H., Reed, D.P., Clark, D.D.: End-to-end arguments in system design.\\nACM Transactions on Computer Systems 2(4), 277\\xe2\\x80\\x93288 (Nov 1984)\\n\\n14. Scribble: Scribble tools (Jan 2018), http://www.scribble.org\\n15. Singh, M.P.: Information-driven interaction-oriented programming: BSPL, the\\n\\nBlindingly Simple Protocol Language. In: Proceedings of the 10th International\\nConference on Autonomous Agents and MultiAgent Systems (AAMAS). pp. 491\\xe2\\x80\\x93\\n498. IFAAMAS, Taipei (May 2011)\\n\\nhttp://www.scribble.org\\n\\n\\n10 Chopra et al.\\n\\n16. Singh, M.P.: Semantics and verification of information-based protocols. In: Pro-\\nceedings of the 11th International Conference on Autonomous Agents and Multi-\\nAgent Systems (AAMAS). pp. 1149\\xe2\\x80\\x931156. IFAAMAS, Valencia, Spain (Jun 2012)\\n\\n17. Winikoff, M., Yadav, N., Padgham, L.: A new hierarchical agent protocol notation.\\nAutonomous Agents and Multi-Agent Systems 32(1), 59\\xe2\\x80\\x93133 (Jul 2017)\\n\\n18. Yolum, P., Singh, M.P.: Flexible protocol specification and execution: Applying\\nevent calculus planning using commitments. In: Proceedings of the 1st Interna-\\ntional Joint Conference on Autonomous Agents and MultiAgent Systems (AA-\\nMAS). pp. 527\\xe2\\x80\\x93534. ACM Press, Bologna (Jul 2002)\\n\\n19. Yoshida, N., Hu, R., Neykova, R., Ng, N.: The Scribble protocol language. In: Pro-\\nceedings of the 8th International Symposium on Trustworthy Global Computing\\n(TGC), Revised Selected Papers. Lecture Notes in Computer Science, vol. 8358,\\npp. 22\\xe2\\x80\\x9341. Springer, Buenos Aires (Aug 2013)\\n\\n\\n\\tConcurrency and Asynchrony in Protocol Languages\\n\\n'