b'\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nOn Enactability of Agent Interaction Protocols:\\nTowards a Unified Approach\\n\\nAngelo Ferrando1, Michael Winikoff2, Stephen Cranefield2, Frank Dignum3, and\\nViviana Mascardi4\\n\\n1 Liverpool University, Liverpool, United Kingdom,\\nangelo.ferrando@liverpool.ac.uk?\\n\\n2 University of Otago, Dunedin, New Zealand, name.surname@otago.ac.nz\\n3 Umea\\xcc\\x8a University, Umea\\xcc\\x8a, Sweden, Utrecht University, The Netherlands, CVUT Prague, Czech\\n\\nRepublic, frank.dignum@umu.se\\n4 Genova University, Genova, Italy, viviana.mascardi@unige.it\\n\\nAbstract. Interactions between agents are usually designed from a global view-\\npoint. However, the implementation of a multi-agent interaction is distributed.\\nThis difference can introduce problems. For instance, it is possible to specify\\nprotocols from a global viewpoint that cannot be implemented as a collection of\\nindividual agents. This leads naturally to the question of whether a given (global)\\nprotocol is enactable. We consider this question in a powerful setting (trace ex-\\npressions), considering a range of message ordering interpretations (specifying\\nwhat it means to say that an interaction step occurs before another), and a range\\nof possible constraints on the semantics of message delivery, corresponding to\\ndifferent properties of the underlying communication middleware.\\n\\nKeywords: Agent Interaction Protocols \\xc2\\xb7 Enactability \\xc2\\xb7 Enforceability \\xc2\\xb7 Imple-\\nmentability \\xc2\\xb7 Realizability \\xc2\\xb7 Projectability \\xc2\\xb7 Trace Expressions\\n\\n1 Introduction\\n\\nIn order to organise her stay in Montreal, Alice books an apartment from Bob via the\\nonline platform AIPbnb. AIPbnb policy states that owners cannot interact with each\\nother, users can interact with owners only via the platform, and if a user finds a better\\nsolution for her accommodation, she must cancel the previous one before she makes a\\nnew reservation for the same dates, otherwise she will be charged for one night there.\\nWhen Alice discovers that Carol rents a cheaper and larger apartment, she decides to\\ncancel the reservation of Bob\\xe2\\x80\\x99s apartment and book Carol\\xe2\\x80\\x99s one. This situation can\\nbe represented by the global Agent Interaction Protocol modifyRes = Alice\\n\\nCanc\\n=\\xe2\\x87\\x92\\n\\nBob \\xc2\\xb7 Alice Res=\\xe2\\x87\\x92 Carol where a1 M=\\xe2\\x87\\x92 a2 models the interaction between a1 and a2\\nto exchange message M , \\xe2\\x80\\x9c\\xc2\\xb7\\xe2\\x80\\x9d models interaction concatenation, and Canc and Res are\\nsent to the recipients by using the AIPbnb platform as required. Alice believes that the\\nabove protocol correctly meets AIPbnb policy, but she is charged for one night in Bob\\xe2\\x80\\x99s\\n\\n? Work supported by EPSRC as part of the ORCA [EP/R026173] and RAIN [EP/R026084]\\nRobotics and AI Hubs.\\n\\nlouisedennis\\nPlaced Image\\n\\n\\n\\n2 A. Ferrando et al.\\n\\napartment by AIPbnb: Carol received Alice\\xe2\\x80\\x99s request before Bob received the cancel-\\nlation, and this violates the policy. What went wrong is the interpretation of \\xe2\\x80\\x9cbefore\\xe2\\x80\\x9d.\\nTo Alice, it meant that she should send Canc before she sent Res, while for AIPbnb it\\n(also) meant that Bob should receive Canc before Carol received Res. This ambiguity\\nwould have had no impact on Alice if the physical communication model underlying\\nAIPbnb guaranteed that between the sending and receiving stages of an interaction,\\nnothing could happen. However, if the communication model provides weaker or no\\nguarantees, it may happen that a message sent before another, is delivered after.\\n\\nThis simple example shows that enacting the intent of a global protocol without\\nclear semantics of the meaning of \\xe2\\x80\\x9cbefore\\xe2\\x80\\x9d, without guarantees from the platform im-\\nplementation on message delivery order, and without hidden communications between\\nthe participants (\\xe2\\x80\\x9ccovert channels\\xe2\\x80\\x9d), may not be possible. Many real situations are sim-\\nilar to this one: for example, a citizen must wait for the bank to have received (and\\nprocessed) the request to add some money to a new empty account, before sending a\\nrequest to move that money to another account, otherwise he can go into overdraft.\\n\\nThis kind of issue is not new in the field and various authors use different terms for\\nglobal protocols that can be enforced by distributed participants: conformant [18], en-\\nforceable [11, 4], enactable [12], implementable [21], projectable [8, 16], realizable [22,\\n19]. The concept behind these names is however the same: by executing the localised\\nversions of the protocol implemented by each participant, the global protocol behaviour\\nis obtained, with no additional communication. We will use the term enactability to de-\\nnote this property. However, despite the large amount of work on enactability, there\\nis no existing work that considers both the intended message ordering and the com-\\nmunication model of the infrastructure in which the agents will be implemented, that\\nrecognises the need to use a decision structure to enforce consistent choices, and that\\nprovides an implementation for checking protocol enactability. Together, these are the\\ninnovative and original features of our contribution (a detailed discussion of related\\nwork is in Section 4).\\n\\nAlthough it might be argued that it is desirable to have robust protocol specifications\\nthat are independent of the underlying platform implementation, we observe that robust-\\nness can make the protocol more complex, and hence harder to maintain. For example,\\nconsidering again the protocol modifyRes = Alice\\n\\nCanc\\n=\\xe2\\x87\\x92 Bob \\xc2\\xb7 Alice Res=\\xe2\\x87\\x92 Carol, we\\n\\nobserve that, depending on which interpretation we choose, we can have different con-\\nclusions on what to expect from the protocol implementation. This can be avoided if we\\nadd additional acknowledgement messages, which gives a more message-intensive pro-\\ntocol such as modifyRes = Alice\\n\\nCanc\\n=\\xe2\\x87\\x92 Bob \\xc2\\xb7 Bob Ack=\\xe2\\x87\\x92 Alice \\xc2\\xb7 Alice Res=\\xe2\\x87\\x92 Carol, in\\n\\nwhich Alice would not be charged erroneously. However, adding additional acknowl-\\nedgement messages increases the complexity of the protocol and reduces opportunities\\nfor concurrency. We therefore prefer to take into account what the underlying imple-\\nmentation guarantees wth respect to communication, so that we can relax our speci-\\nfications, and use as simple a protocol as possible. Additionally, a protocol that is not\\nenactable in some platform may be enactable in some other platform. Our work is there-\\nfore relevant to both platform designers and protocol designers.\\n\\n\\n\\nOn Enactability of Agent Interaction Protocols: Towards a Unified Approach 3\\n\\n2 Background\\n\\nTrace Expressions. Trace expressions [3] are a compact and expressive formalism in-\\nspired by global types [1] and then extended and exploited in different application do-\\nmains [14, 2, 13]. Initially devised for runtime verification of multiagent systems, trace\\nexpressions are expressive, and can define context-sensitive languages.\\n\\nA trace expression \\xcf\\x84 denotes a set of possibly infinite event traces, and is defined\\non top of the following operators:5\\n\\n\\xe2\\x80\\x93 \\xef\\xbf\\xbd (empty trace), denoting the singleton set {\\xe3\\x80\\x88\\xe3\\x80\\x89} containing the empty event trace \\xe3\\x80\\x88\\xe3\\x80\\x89.\\n\\xe2\\x80\\x93 M (event), denoting a singleton set {\\xe3\\x80\\x88M\\xe3\\x80\\x89} containing the event trace \\xe3\\x80\\x88M\\xe3\\x80\\x89.\\n\\xe2\\x80\\x93 \\xcf\\x841\\xc2\\xb7\\xcf\\x842 (concatenation), denoting the set of all traces obtained by concatenating the\\n\\ntraces of \\xcf\\x841 with those of \\xcf\\x842.\\n\\xe2\\x80\\x93 \\xcf\\x841\\xe2\\x88\\xa7\\xcf\\x842 (intersection), denoting the intersection of the traces of \\xcf\\x841 and \\xcf\\x842.\\n\\xe2\\x80\\x93 \\xcf\\x841\\xe2\\x88\\xa8\\xcf\\x842 (union), denoting the union of the traces of \\xcf\\x841 and \\xcf\\x842.\\n\\xe2\\x80\\x93 \\xcf\\x841|\\xcf\\x842 (shuffle), denoting the union of the sets obtained by shuffling each trace of \\xcf\\x841\\n\\nwith each trace of \\xcf\\x842 (see [7] for a more precise definition).\\n\\nTrace expressions are cyclic terms, thus they can support recursion without intro-\\nducing an explicit construct.\\n\\nAs customary, the operational semantics of trace expressions, defined in [3], is spec-\\nified by a transition relation \\xce\\xb4 \\xe2\\x8a\\x86 T \\xc3\\x97 E \\xc3\\x97 T , where T and E denote the sets of trace\\nexpressions and of events, respectively. We do not present all the transition rules for\\nspace constraints. They are standard ones (see e.g. [3]) that state, for example, that\\n\\xce\\xb4(ev \\xc2\\xb7 \\xcf\\x84, ev, \\xcf\\x84) (the protocol whose state is modelled by ev \\xc2\\xb7 \\xcf\\x84 can move to state \\xcf\\x84 if ev\\noccurs), and that \\xce\\xb4(\\xcf\\x841\\xe2\\x88\\xa8 \\xcf\\x842, ev, \\xcf\\x84) if \\xce\\xb4(\\xcf\\x841, ev, \\xcf\\x84) (if the protocol whose state is modelled\\nby \\xcf\\x841 can move to state \\xcf\\x84 if ev occurs, then also the protocol whose state is modelled\\nby \\xcf\\x841 \\xe2\\x88\\xa8 \\xcf\\x842 can). The denotational semantics is defined as follows, Where t1 ./ t2 is the\\nset of all interleavings of t1 and t2, and \\xe2\\x97\\xa6 is concatenation over sequences:\\n\\nJ\\xef\\xbf\\xbdK = {\\xe3\\x80\\x88\\xe3\\x80\\x89}\\nJMK = {\\xe3\\x80\\x88M\\xe3\\x80\\x89}\\n\\nJ\\xcf\\x841 \\xc2\\xb7 \\xcf\\x842K = {t1 \\xe2\\x97\\xa6 t2 | t1 \\xe2\\x88\\x88 J\\xcf\\x841K \\xe2\\x88\\xa7 t2 \\xe2\\x88\\x88 J\\xcf\\x842K}\\nJ\\xcf\\x841 \\xe2\\x88\\xa7 \\xcf\\x842K = J\\xcf\\x841K \\xe2\\x88\\xa9 J\\xcf\\x842K\\nJ\\xcf\\x841 \\xe2\\x88\\xa8 \\xcf\\x842K = J\\xcf\\x841K \\xe2\\x88\\xaa J\\xcf\\x842K\\n\\nJ\\xcf\\x841|\\xcf\\x842K = {z | t1 \\xe2\\x88\\x88 J\\xcf\\x841K \\xe2\\x88\\xa7 t2 \\xe2\\x88\\x88 J\\xcf\\x842K \\xe2\\x88\\xa7 z \\xe2\\x88\\x88 t1 ./ t2}\\n\\nEvents can be, in principle, of any kind. In this paper, we will limit ourselves to\\nconsider interaction and message events.\\n\\nAn interaction has the form a\\nM\\n=\\xe2\\x87\\x92 b and gives information on the protocol from the\\n\\nglobal perspective, collapsing sending and receiving into a single event. We say that \\xcf\\x84\\n\\n5 Binary operators associate from left, and are listed in decreasing order of precedence; that\\nis, the first operator has the highest precedence. The operators \\xe2\\x80\\x9c\\xe2\\x88\\xa8\\xe2\\x80\\x9d and \\xe2\\x80\\x9c\\xe2\\x88\\xa7\\xe2\\x80\\x9d are the standard\\nnotation for trace expressions.\\n\\n\\n\\n4 A. Ferrando et al.\\n\\nis an interaction protocol if all the events therein are interactions. Interaction protocols\\ntake other names in other communities, such as Interaction Oriented Choreography\\n[18] in the service-oriented computing community, and global type in the community\\nworking on process calculi and types [9].\\n\\nMessage events have the form aM ! (a sends M ) and bM? (b receives M ). They\\nmodel actions that one agent can execute, hence taking a local perspective. A trace\\nexpression where all events are messages will be named a message protocol throughout\\nthe paper. Message protocols have different names in different communities, such as\\nProcess Oriented Choreography [18] and \\xe2\\x80\\x9clocal type\\xe2\\x80\\x9d or \\xe2\\x80\\x9csession type\\xe2\\x80\\x9d in the global\\ntypes community [15, 24].\\n\\nCommunication Models. Given that in our proposal we explicitly take the communica-\\ntion model supported by the MAS infrastructure into account, we provide a summary\\nof communication models based on [10]. We use CM0 to CM6 to identify them in a\\ncompact way.\\nCM0: Synchronous Communication. Sending and receiving are synchronised: the\\nsender cannot send if the receiver is not ready to receive.\\nCM1: Realisable with Synchronous Communication (RSC). After a communication\\ntransition consisting of a send event of a message, the only possible communication\\ntransition is the receive event of this message. This asynchronous model is the closest\\none to synchronous communication and can be implemented with a 1-slot unique buffer\\nshared by all agents.\\nCM2: FIFO n-n communication. Messages are globally ordered and are delivered in\\ntheir emission order: if sending of M1 takes place before sending of M2, then reception\\nof M1 must take place before reception of M2. This model can be implemented by\\nmeans of a shared centralised object, such as unique queue.\\nCM3: FIFO 1-n communication. Messages from the same sender are delivered in the\\norder in which they were sent. It can be implemented by giving each agent a unique\\nqueue where it puts its outgoing messages, with peers fetching messages from this\\nqueue.\\nCM4: FIFO n-1 communication. A send event is implicitly and globally ordered with\\nregard to all other sending actions toward the same agent. This means that if agent b\\nreceives M1 (sent by agent a) and later it receives M2 (sent by agent c), b knows that\\nthe sending of M1 occurred before the sending of M2 in the global execution order,\\neven if there is no causal path between the two sending actions. The implementation of\\nthis model can, similarly to FIFO 1-n, be done by providing each agent with a queue:\\nmessages are sent by putting them into the queue of the recipient agent.\\nCM5: Causal. Messages are delivered according to the causality of their emissions\\n[17]: if a message M1 is causally sent before a message M2 then an agent cannot get\\nM2 before M1. Implementing this model requires sharing the causality relation.\\nCM6: Fully Asynchronous. No order on message delivery is imposed. Messages can\\novertake others or be arbitrarily delayed. The implementation can be modelled by a bag.\\n\\nMessage Ordering. The statement \\xe2\\x80\\x9cone interaction comes before another\\xe2\\x80\\x9d is ambigu-\\nous, as exemplified in Section 1. This ambiguity has been recognised by some authors\\nwho suggested how to interpret message ordering when moving from the interaction\\n\\n\\n\\nOn Enactability of Agent Interaction Protocols: Towards a Unified Approach 5\\n\\n(global) level to the message (local) level. In this section we summarise and compare\\nthe proposals by Lanese et al. [18] and Desai and Singh [12].\\n\\nTo identify the interpretations, we will use the acronyms used in [12] when avail-\\nable, and our own acronyms otherwise. The starting point for interpreting message or-\\ndering is the interaction protocol \\xcf\\x84 = a\\n\\nM1\\n=\\xe2\\x87\\x92 b\\xc2\\xb7c M2=\\xe2\\x87\\x92 d. For the sake of clarity, we\\n\\ndenote aM1! with s1, bM1? with r1, cM2! with s2, and dM2? with r2; we characterise\\nthe message ordering interpretations by the traces of message events that respect them.\\nRS: Under this message ordering interpretation the meaning of \\xe2\\x80\\x9cinteraction event M1\\noccurs beforeM2\\xe2\\x80\\x9d is thatM1 is received beforeM2 is sent. The set of traces that respect\\nthis model is {\\xe3\\x80\\x88s1, r1, s2, r2\\xe3\\x80\\x89}. This interpretation is named RS (receive before send)\\nin [12] and disjoint semantics in [18].\\nSS: M1 is sent before M2, and there are no constraints on the delivery order. The set of\\ntraces that respect this model is {\\xe3\\x80\\x88s1, r1, s2, r2\\xe3\\x80\\x89, \\xe3\\x80\\x88s1, s2, r1, r2\\xe3\\x80\\x89, \\xe3\\x80\\x88s1, s2, r2, r1\\xe3\\x80\\x89}. This\\ninterpretation is named SS (send before send) in [12] and sender semantics in [18].\\nRR: M1 is received before M2, and there are no constraints on the sending order. The\\nset of traces that respect this model is {\\xe3\\x80\\x88s1, r1, s2, r2\\xe3\\x80\\x89, \\xe3\\x80\\x88s1, s2, r1, r2\\xe3\\x80\\x89, \\xe3\\x80\\x88s2, s1, r1, r2\\xe3\\x80\\x89}.\\nThis interpretation is named RR (receive before receive) in [12] and receiver semantics\\nin [18].\\nRR & SS: this combines the requirements of RR and of SS: M1 is sent before M2 is\\nsent and also M1 is received before M2 is received. The set of traces that respect this\\nmodel is {\\xe3\\x80\\x88s1, r1, s2, r2\\xe3\\x80\\x89, \\xe3\\x80\\x88s1, s2, r1, r2\\xe3\\x80\\x89}: both s1 comes before s2 (\\xe2\\x80\\x9ccoming before\\xe2\\x80\\x9d\\naccording to the senders), and r1 comes before r2 (\\xe2\\x80\\x9ccoming before\\xe2\\x80\\x9d according to the\\nreceivers). This interpretation is named sender-receiver semantics in [18].\\nSR: M1 is sent before M2 is received. The set of traces that respect this model is\\n{\\xe3\\x80\\x88s1, r1, s2, r2\\xe3\\x80\\x89, \\xe3\\x80\\x88s1, s2, r1, r2\\xe3\\x80\\x89, \\xe3\\x80\\x88s1, s2, r2, r1\\xe3\\x80\\x89, \\xe3\\x80\\x88s2, s1, r1, r2\\xe3\\x80\\x89, \\xe3\\x80\\x88s2, s1, r2, r1\\xe3\\x80\\x89}. This\\ninterpretation is named SR (send before receive) in [12]\\n\\nIt is easy to see that the following inclusions among asynchronous models hold:\\nRS \\xe2\\x8a\\x82 RR & SS \\xe2\\x8a\\x82 SS \\xe2\\x8a\\x82 SR and RS \\xe2\\x8a\\x82 RR & SS \\xe2\\x8a\\x82 RR \\xe2\\x8a\\x82 SR. The SS and RR\\ninterpretations are not comparable. In the remainder of this paper we consider only the\\nfour interpretations defined by Desai & Singh, i.e. we do not consider \\xe2\\x80\\x9cRR & SS\\xe2\\x80\\x9d.\\n\\n3 Defining Enactability using a Semantic Approach\\n\\nBasic Notation. In the following, let ComModel = {CM1, CM2, CM3, CM4, CM5,\\nCM6} be the set of possible (asynchronous) communication models, and MOISet =\\n{SS, SR, RS, RR } the set of possible message order interpretations that can be imposed.\\nWe also define A = {a, b, c, d, a1, a2, . . . , an} to be the set of agents involved in the\\ninteraction protocol.\\n\\nRecall that we consider both interaction and message protocols. When we say that\\n\\xcf\\x84 is an interaction protocol, we mean that the protocol represents sequences of inter-\\naction events. The set of traces recognized is obtained following the semantics defined\\nin Section 2, and for an interaction protocol \\xcf\\x84 we define6 I(\\xcf\\x84) to be the set of inter-\\nactions involved in the interaction protocol: I(\\xcf\\x84) = {i | \\xe2\\x88\\x83I : I \\xe2\\x88\\x88 J\\xcf\\x84K \\xe2\\x88\\xa7 i \\xe2\\x88\\x88 I}.\\n\\n6 We use \\xe2\\x80\\x9c\\xe2\\x88\\x88\\xe2\\x80\\x9d to also denote membership of an item in a sequence.\\n\\n\\n\\n6 A. Ferrando et al.\\n\\nWe define I to be the set of all possible interaction events. Similarly, when \\xcf\\x84 is a\\nmessage protocol, it represents sequences of send and receive events of the form aM !\\n(send event) and bM? (receive event), and given a particular set of possible interactions\\nI, we define EI to be the corresponding set of events: EI = {aM ! | \\xe2\\x88\\x83b\\xe2\\x88\\x88A . a\\n\\nM\\n=\\xe2\\x87\\x92\\n\\nb \\xe2\\x88\\x88 I} \\xe2\\x88\\xaa {bM? | \\xe2\\x88\\x83a\\xe2\\x88\\x88A . a\\nM\\n=\\xe2\\x87\\x92 b \\xe2\\x88\\x88 I}. In a message protocol \\xcf\\x84 we have that\\n\\nE \\xe2\\x88\\x88 J\\xcf\\x84K =\\xe2\\x87\\x92 \\xe2\\x88\\x80e\\xe2\\x88\\x88E . e \\xe2\\x88\\x88 EI(\\xcf\\x84). Given a message protocol \\xcf\\x84 we also define E(\\xcf\\x84)\\nto be the set of message events that occur in the protocol.\\n\\nNext, we define the language of traces (i.e. of sequences of events) for interaction\\nprotocols and message protocols. For interaction protocols, the set of all possible traces\\nis defined to be7: LI = I\\n\\n\\xe2\\x88\\x97\\xe2\\x88\\xaaI\\xcf\\x89 . For message protocols the definition is somewhat more\\ncomplex, since there is a relationship between a send and a receive event. Specifically,\\nthe set of all possible traces of events is constrained so that a message being received\\nmust be preceded by that message having been sent. We also constrain the set so that\\neach message can be sent at most once, and received at most once (i.e. message names\\nare unique). The assumption is made by most authors, see [10] for example, and is\\nconsidered harmless, since we can integrate many elements to the notion of \\xe2\\x80\\x9cmessage\\nname\\xe2\\x80\\x9d, such as content, protocol ID and conversation ID, to discriminate between mes-\\nsages at design time. Formally (where dom(E) is standard notation for the domain of a\\nfunction, here viewing a sequence as a function from numbers to elements):\\n\\nLEI = {E \\xe2\\x88\\x88 E\\n\\xe2\\x88\\x97\\nI \\xe2\\x88\\xaa E\\n\\n\\xcf\\x89\\nI |\\n\\n(\\xe2\\x88\\x80i,j\\xe2\\x88\\x88dom(E) . E[i] = aM ! \\xe2\\x88\\xa7 E[j] = aM ! =\\xe2\\x87\\x92 i = j) \\xe2\\x88\\xa7\\n(\\xe2\\x88\\x80i,j\\xe2\\x88\\x88dom(E) . E[i] = bM? \\xe2\\x88\\xa7 E[j] = bM? =\\xe2\\x87\\x92 i = j) \\xe2\\x88\\xa7\\n(\\xe2\\x88\\x80i\\xe2\\x88\\x88dom(E) . E[i] = bM? =\\xe2\\x87\\x92 (\\xe2\\x88\\x83j\\xe2\\x88\\x88dom(E) . E[j] = aM ! \\xe2\\x88\\xa7 j < i))\\n\\nMessage Order Interpretation (MOI). As discussed earlier, we follow prior work in\\nconsidering four message ordering interpretations (SS, SR, RS, and RR). We formalise\\nthis by defining a variant semantics that takes an interaction protocol \\xcf\\x84 and returns its\\nsemantics in terms of events rather than interactions. The possible sequences of events\\nare constrained: given a situation where \\xcf\\x84 specifies that M1 must occur before M2,\\nwe constrain the possible sequence of events with the appropriate constraint on events\\ncorresponding to the selected MOI.\\n\\nDefinition 1 (Order on interactions in a trace). Let I \\xe2\\x88\\x88 LI be a trace of interaction\\nevents, E \\xe2\\x88\\x88 LEI be a trace of send and receive events, moi \\xe2\\x88\\x88 MOISet a message or-\\ndering interpretation, and a\\n\\nM1\\n=\\xe2\\x87\\x92 b \\xe2\\x88\\x88 I, c M2=\\xe2\\x87\\x92 d \\xe2\\x88\\x88 I two interactions. Abbreviating\\n\\na\\nM1\\n=\\xe2\\x87\\x92 b as I1 and c\\n\\nM2\\n=\\xe2\\x87\\x92 d as I2, we define the message ordering interpretation con-\\n\\nstraint, denoted I1 \\xe2\\x89\\xbaEmoi I2, as follows:\\nI1 \\xe2\\x89\\xbaESS I2 iff aM1! \\xe2\\x89\\xbaE cM2! I1 \\xe2\\x89\\xba\\n\\nE\\nSR I2 iff aM1! \\xe2\\x89\\xbaE dM2?\\n\\nI1 \\xe2\\x89\\xbaERS I2 iff bM1? \\xe2\\x89\\xbaE cM2! I1 \\xe2\\x89\\xba\\nE\\nRR I2 iff bM1? \\xe2\\x89\\xbaE dM2?\\n\\nwhere e1 \\xe2\\x89\\xbaE e2 iff \\xe2\\x88\\x83i,j\\xe2\\x88\\x88dom(E) . E[i] = e1 \\xe2\\x88\\xa7 E[j] = e2 \\xe2\\x88\\xa7 i < j is the constraint that\\nin event trace E the event e1 occurs before e2.\\n\\n7 The superscripts \\xe2\\x88\\x97 and \\xcf\\x89 are standard notations for (respectively) all finite (all infinite) se-\\nquences built from a given set.\\n\\n\\n\\nOn Enactability of Agent Interaction Protocols: Towards a Unified Approach 7\\n\\nFormalising the MOI is not as simple as it might seem. An obvious approach that\\ndoes not work is to compute the semantics of the interaction protocol \\xcf\\x84 , and then map\\neach sequence I \\xe2\\x88\\x88 J\\xcf\\x84K to a set of message event traces. This does not work because\\nthe trace is linear, and therefore a total order, whereas a protocol can specify a partial\\norder8 (and indeed, in the case of the SR MOI, the ordering may not even be partial,\\nsince SR is not transitive). Instead, we define a variant semantics, denoted J\\xcf\\x84Kmoi, which\\nis compositional. The semantics follow the standard semantics (Section 2) with a few\\nexceptions. Firstly, the semantics of an interaction I is given as the sequence of sending\\nthe message, followed by receiving it (denoted s(I) and r(I), respectively). Secondly,\\nthe semantics for a sequence \\xcf\\x841 \\xc2\\xb7\\xcf\\x842 is given in terms of the semantics of \\xcf\\x841 and \\xcf\\x842. These\\nare then combined by interleaving them (rather than simply concatenating them), but\\nwith the constraint that the result must satisfy the appropriate MOI constraint (I1 \\xe2\\x89\\xbaEmoi\\nI2) for all possible final messages of \\xcf\\x841 (I1) and all possible initial messages of \\xcf\\x842 (I2).\\nDetermining initial and final messages is itself somewhat complex, and is done using\\npartially ordered sets.\\n\\nA partially ordered set (poset) is a pair (E,<) where E is the set of elements (in\\nthis case interactions) and < is a transitive binary relation on E. We define the union\\noperator to act piecewise on posets, and to take the transitive closure of the resulting\\nrelation, i.e. (E1, <1) \\xe2\\x88\\xaa (E2, <2) = (E1 \\xe2\\x88\\xaa E2, (<1 \\xe2\\x88\\xaa <2)\\xe2\\x88\\x97). The sets of minimal and\\nmaximal elements of a poset P are denoted min(P ) and max(P ), respectively.\\n\\nWe can then define the poset of an interaction protocol as follows:\\n\\nposet(\\xef\\xbf\\xbd) = (\\xe2\\x88\\x85,\\xe2\\x88\\x85)\\nposet(I) = ({I},\\xe2\\x88\\x85)\\n\\nposet(\\xcf\\x841 \\xe2\\x88\\xa7 \\xcf\\x842) = poset(\\xcf\\x841) \\xe2\\x88\\xaa poset(\\xcf\\x842)\\nposet(\\xcf\\x841 | \\xcf\\x842) = poset(\\xcf\\x841) \\xe2\\x88\\xaa poset(\\xcf\\x842)\\nposet(\\xcf\\x841 \\xe2\\x88\\xa8 \\xcf\\x842) = poset(\\xcf\\x841) \\xe2\\x88\\xaa poset(\\xcf\\x842)\\nposet(\\xcf\\x841 \\xc2\\xb7 \\xcf\\x842) = poset(\\xcf\\x841) \\xc2\\xb7 poset(\\xcf\\x842)\\n\\n(E1, <1) \\xc2\\xb7 (E2, <2) = (E1 \\xe2\\x88\\xaa E2, <1 \\xe2\\x88\\xaa <2 \\xe2\\x88\\xaa E1\\xc3\\x97E2)\\n\\nwhere we define a sequence of two posets (E1, <1) \\xc2\\xb7 (E2, <2) by collecting the order-\\nings of each of E1 and E2, and adding additional ordering constraints between every\\nelement of E1 and every element of E2. We can now proceed to define the variant\\ncompositional semantics J\\xcf\\x84Kmoi.\\n\\n8 An illustrative example is \\xcf\\x84 = (M1 \\xc2\\xb7 M2) | M3. This simple protocol has\\nthree sequences of interactions: {\\xe3\\x80\\x88M1,M2,M3\\xe3\\x80\\x89, \\xe3\\x80\\x88M1,M3,M2\\xe3\\x80\\x89, \\xe3\\x80\\x88M3,M1,M2\\xe3\\x80\\x89}. Assum-\\ning an RS message ordering interpretation, then each of the message sequences cor-\\nresponds to exactly one sequence of events, giving (where we abbreviate sending\\nand receiving M as respectively M ! and M?): {\\xe3\\x80\\x88M1!,M1?,M2!,M2?,M3!,M3?\\xe3\\x80\\x89,\\n\\xe3\\x80\\x88M1!,M1?,M3!,M3?,M2!,M2?\\xe3\\x80\\x89, \\xe3\\x80\\x88M3!,M3?,M1!,M1?,M2!,M2?\\xe3\\x80\\x89}. However, the pro-\\ntocol does not specify any constraint on M3, so should also allow other interpretations where\\nthe occurrences of M3! and M3! are not constrained relative to the other events, for example\\n\\xe3\\x80\\x88M1!,M1!,M3!,M2!,M2?,M3?\\xe3\\x80\\x89.\\n\\n\\n\\n8 A. Ferrando et al.\\n\\nJ\\xef\\xbf\\xbdKmoi = {\\xef\\xbf\\xbd}\\nJIKmoi = {\\xe3\\x80\\x88s(I), r(I)\\xe3\\x80\\x89}\\n\\nJ\\xcf\\x841 \\xe2\\x88\\xa8 \\xcf\\x842Kmoi = J\\xcf\\x841Kmoi \\xe2\\x88\\xaa J\\xcf\\x841Kmoi\\nJ\\xcf\\x841 \\xe2\\x88\\xa7 \\xcf\\x842Kmoi = J\\xcf\\x841Kmoi \\xe2\\x88\\xa9 J\\xcf\\x841Kmoi\\nJ\\xcf\\x841 \\xc2\\xb7 \\xcf\\x842Kmoi = {t | t1 \\xe2\\x88\\x88 J\\xcf\\x841Kmoi \\xe2\\x88\\xa7 t2 \\xe2\\x88\\x88 J\\xcf\\x842Kmoi \\xe2\\x88\\xa7 t \\xe2\\x88\\x88 t1 ./ t2 \\xe2\\x88\\xa7\\n\\n\\xe2\\x88\\x80I1 \\xe2\\x88\\x88 max(poset(\\xcf\\x841)),\\xe2\\x88\\x80I2 \\xe2\\x88\\x88 min(poset(\\xcf\\x842)) . I1 \\xe2\\x89\\xbatmoi I2}\\nJ\\xcf\\x841|\\xcf\\x842Kmoi = {z | t1 \\xe2\\x88\\x88 J\\xcf\\x841Kmoi \\xe2\\x88\\xa7 t2 \\xe2\\x88\\x88 J\\xcf\\x842Kmoi \\xe2\\x88\\xa7 z \\xe2\\x88\\x88 t1 ./ t2}\\n\\nWhere t1 ./ t2 is the set of all interleavings of t1 and t2.\\n\\nCommunication Model Semantics. We formalise the defined communication model\\nsemantics by defining for each communication model CMi a corresponding language\\nof event traces that incorporates the appropriate restriction, ruling out event sequences\\nthat violate the communication model. For example, for CM1 the constraint is that\\nimmediately after each sending event in u we have its corresponding receiving event,\\nwith nothing in the middle; etc. Note that each LEICMi takes as a parameter the set of\\nmessage events EI .\\n\\nLEICM1 = {E \\xe2\\x88\\x88 LEI |\\xe2\\x88\\x80aM1=\\xe2\\x87\\x92b\\xe2\\x88\\x88I .\\xe2\\x88\\x80k\\xe2\\x88\\x88dom(E) . aM1! = E[k \\xe2\\x88\\x92 1] =\\xe2\\x87\\x92 bM1? = E[k]}\\n\\nLEICM2 = {E \\xe2\\x88\\x88 LEI |\\xe2\\x88\\x80aM1=\\xe2\\x87\\x92b\\xe2\\x88\\x88I .\\xe2\\x88\\x80cM2=\\xe2\\x87\\x92d\\xe2\\x88\\x88I .\\xe2\\x88\\x80i,j,k,l\\xe2\\x88\\x88dom(E) . (bM1? = E[i] \\xe2\\x88\\xa7\\n\\ndM2? = E[j] \\xe2\\x88\\xa7 aM1! = E[k] \\xe2\\x88\\xa7 cM2! = E[l] \\xe2\\x88\\xa7 k < l) =\\xe2\\x87\\x92 i < j}\\nLEICM3 = {E \\xe2\\x88\\x88 LEI |\\xe2\\x88\\x80aM1=\\xe2\\x87\\x92b\\xe2\\x88\\x88I .\\xe2\\x88\\x80aM2=\\xe2\\x87\\x92d\\xe2\\x88\\x88I .\\xe2\\x88\\x80i,j,k,l\\xe2\\x88\\x88dom(E) . (bM1? = E[i] \\xe2\\x88\\xa7\\n\\ndM2? = E[j] \\xe2\\x88\\xa7 aM1! = E[k] \\xe2\\x88\\xa7 aM2! = E[l] \\xe2\\x88\\xa7 k < l) =\\xe2\\x87\\x92 i < j}\\nLEICM4 = {E \\xe2\\x88\\x88 LEI |\\xe2\\x88\\x80aM1=\\xe2\\x87\\x92b\\xe2\\x88\\x88I .\\xe2\\x88\\x80cM2=\\xe2\\x87\\x92b\\xe2\\x88\\x88I .\\xe2\\x88\\x80i,j,k,l\\xe2\\x88\\x88dom(E) . (bM1? = E[i] \\xe2\\x88\\xa7\\n\\nbM2? = E[j] \\xe2\\x88\\xa7 aM1! = E[k] \\xe2\\x88\\xa7 cM2! = E[l] \\xe2\\x88\\xa7 k < l) =\\xe2\\x87\\x92 i < j}\\nLEICM5 = {E \\xe2\\x88\\x88 LEI |\\xe2\\x88\\x80aM1=\\xe2\\x87\\x92b\\xe2\\x88\\x88I .\\xe2\\x88\\x80aM2=\\xe2\\x87\\x92b\\xe2\\x88\\x88I .\\xe2\\x88\\x80i,j,k,l\\xe2\\x88\\x88dom(E) . (bM1? = E[i] \\xe2\\x88\\xa7\\n\\nbM2? = E[j] \\xe2\\x88\\xa7 aM1! \\xe2\\x89\\xbaECausal aM2!) =\\xe2\\x87\\x92 i < j}\\nwhere aM1! \\xe2\\x89\\xbauCausal bM2! \\xe2\\x87\\x90\\xe2\\x87\\x92\\n\\n((a = b \\xe2\\x88\\xa8M1 =M2) \\xe2\\x88\\xa7\\n\\xe2\\x88\\x83i,j\\xe2\\x88\\x88dom(u).(u[i] = aM1! \\xe2\\x88\\xa7 bM2! = u[j] \\xe2\\x88\\xa7 i < j))\\n\\xe2\\x88\\xa8 (\\xe2\\x88\\x83ev\\xe2\\x88\\x88E .aM1! \\xe2\\x89\\xbauCausal ev \\xe2\\x88\\xa7 ev \\xe2\\x89\\xba\\n\\nu\\nCausal bM2!)\\n\\nLEICM6 = LEI\\nWe can then apply a particular communication model to an interaction protocol\\n\\n\\xcf\\x84i using J\\xcf\\x84iKCMmoi, and to a message protocol \\xcf\\x84m using J\\xcf\\x84mK\\nCM, which are defined as\\n\\nfollows9.\\n9 Note that in the first line we have an interaction protocol \\xcf\\x84i, and so the set of message events\\n\\nis given by determining the set of interaction events I(\\xcf\\x84), and then determining the set of\\n\\n\\n\\nOn Enactability of Agent Interaction Protocols: Towards a Unified Approach 9\\n\\nJ\\xcf\\x84iKCMmoi = J\\xcf\\x84iKmoi \\xe2\\x88\\xa9 L\\nEI(\\xcf\\x84)\\nCM\\n\\nJ\\xcf\\x84mKCM = J\\xcf\\x84mK \\xe2\\x88\\xa9 L\\nE(\\xcf\\x84)\\nCM\\n\\nProjection. Projection is defined, intuitively, as focusing on the aspects of the protocol\\nthat are relevant for a given role. It is defined as follows, where we write \\xcf\\x84A to denote\\nprojecting trace \\xcf\\x84 for role A.\\n\\n(\\xef\\xbf\\xbd)A = \\xef\\xbf\\xbd\\n\\n(a\\nM\\n=\\xe2\\x87\\x92 b)A =\\n\\n\\xef\\xa3\\xb1\\xef\\xa3\\xb4\\xef\\xa3\\xb2\\n\\xef\\xa3\\xb4\\xef\\xa3\\xb3\\naM !, if a = A\\nbM?, if b = A\\n\\xef\\xbf\\xbd, otherwise\\n\\n(aM !)A =\\n\\n{\\naM !, if a = A\\n\\xef\\xbf\\xbd, otherwise\\n\\n(aM?)A =\\n\\n{\\naM?, if a = A\\n\\xef\\xbf\\xbd, otherwise\\n\\n(\\xcf\\x841 \\xe2\\x8a\\x97 \\xcf\\x842)A = (\\xcf\\x841)A \\xe2\\x8a\\x97 (\\xcf\\x842)A (where \\xe2\\x8a\\x97 is any operator)\\n\\nWe then define the distribution of \\xcf\\x84 , denoted p\\xcf\\x84q, where \\xcf\\x84 involves roles a1 . . . an as10:\\n\\np\\xcf\\x84q = \\xcf\\x84a1\\xe2\\x80\\x96 \\xc2\\xb7 \\xc2\\xb7 \\xc2\\xb7 \\xe2\\x80\\x96\\xcf\\x84an\\n\\nTo give an example, let us consider again the scenario proposed in Section 1. Alice\\ndecided to book Carol\\xe2\\x80\\x99s apartment and now Carol needs some information from Alice\\nin order to complete the reservation. This information can be wrong or incomplete, in\\nwhich case Carol gives Alice an opportunity to amend the information, and in either\\ncase the interaction then concludes with Carol confirming the booking. This can be\\nrepresented as the following specification:\\n\\nreqInfo = Alice\\nInfo\\n=\\xe2\\x87\\x92 Carol \\xc2\\xb7\\n\\n(Carol\\nWrong\\n=\\xe2\\x87\\x92 Alice \\xc2\\xb7 Alice Info\\n\\n\\xe2\\x80\\xb2\\n\\n=\\xe2\\x87\\x92 Carol \\xe2\\x88\\xa8 \\xef\\xbf\\xbd) \\xc2\\xb7\\n\\nCarol\\nBooked\\n=\\xe2\\x87\\x92 Alice\\n\\nLet us consider main as the sequential combination of the two protocols: main =\\nmodifyRes \\xc2\\xb7 reqInfo. Then the projection of main on each single agent gives the\\nfollowing distribution.\\n\\nmessage events EI(\\xcf\\x84). By contrast, in the second line, \\xcf\\x84m is a message protocol, so we just\\ndetermine the set of message events directly (E(\\xcf\\x84)).\\n\\n10 We use \\xe2\\x80\\x96 to distinguish between parallel composition of different agents, and parallel compo-\\nsition within a protocol. This distinction is used later in this section.\\n\\n\\n\\n10 A. Ferrando et al.\\n\\npmainq = mainAlice \\xe2\\x80\\x96 mainBob \\xe2\\x80\\x96 mainCarol\\n\\nmainAlice = modifyResAlice \\xc2\\xb7 reqInfoAlice\\n\\nmodifyResAlice = AliceCanc! \\xc2\\xb7 AliceRes!\\nreqInfoAlice = AliceInfo! \\xc2\\xb7 (AliceWrong? \\xc2\\xb7 AliceInfo\\xe2\\x80\\xb2! \\xe2\\x88\\xa8 \\xef\\xbf\\xbd) \\xc2\\xb7\\n\\nAliceBooked?\\n\\nmainBob = modifyResBob \\xc2\\xb7 reqInfoBob = BobCanc? \\xc2\\xb7 \\xef\\xbf\\xbd\\nmainCarol = modifyResCarol \\xc2\\xb7 reqInfoCarol\\n\\nmodifyResCarol = CarolRes?\\n\\nreqInfoCarol = CarolInfo? \\xc2\\xb7 (CarolWrong! \\xc2\\xb7 CarolInfo\\xe2\\x80\\xb2? \\xe2\\x88\\xa8 \\xef\\xbf\\xbd) \\xc2\\xb7\\nCarolBooked!\\n\\nIn order to define the semantics of a projected protocol we need to first define what\\nwe term a decision structure. This is needed in the semantics in order to deal correctly\\nwith projected protocols. Specifically, the intuition for enactability (see Section 3) is that\\nan interaction protocol \\xcf\\x84 involving, say, three roles a, b and c is enactable iff there exist\\nthree protocols \\xcf\\x84a, \\xcf\\x84 b and \\xcf\\x84 c such that their concurrent interleaving results in the same\\nbehaviour as the original protocol. However, when a protocol contains choices (\\xe2\\x88\\xa8) we\\nneed to ensure that the occurrences of\\xe2\\x88\\xa8 in each of \\xcf\\x84a, \\xcf\\x84 b and \\xcf\\x84 c arising from the same\\xe2\\x88\\xa8\\nin \\xcf\\x84 are treated consistently. For example, consider the protocol \\xcf\\x84 = a\\n\\nM1\\n=\\xe2\\x87\\x92 b\\xe2\\x88\\xa8a M2=\\xe2\\x87\\x92 c.\\n\\nThis protocol is simple: it specifies that agent a can either send a message (M1) to b, or\\nit can send a different message (\\xe2\\x80\\x9cM2\\xe2\\x80\\x9d) to agent c. When we distribute the protocol by\\nprojecting it (see Section 3) and forming \\xcf\\x84a\\xe2\\x80\\x96\\xcf\\x84 b\\xe2\\x80\\x96\\xcf\\x84 c we obtain the distributed protocol\\n(aM1! \\xe2\\x88\\xa8 aM2!)\\xe2\\x80\\x96(bM1? \\xe2\\x88\\xa8 \\xce\\xb5)\\xe2\\x80\\x96(\\xce\\xb5 \\xe2\\x88\\xa8 cM2?). However, if we interpret each \\xe2\\x88\\xa8 indepen-\\ndently (as the semantics would naturally do) then we can have inconsistent choices. For\\nexample, we could have (aM1!)\\xe2\\x80\\x96(\\xce\\xb5)\\xe2\\x80\\x96(\\xce\\xb5) where the message is sent by a, but b does not\\nelect to receive it. So what we need to do is ensure that each of the three occurrences of\\n\\xe2\\x80\\x9c\\xe2\\x88\\xa8\\xe2\\x80\\x9d represent the same choice, and that the choice should be made consistently.\\n\\nThe heart of the issue is that the trace expression notation offers a choice operator\\n(\\xe2\\x88\\xa8), which is adequate for global protocols. However, for local protocols it is important\\nto be able to distinguish between a choice that represents a free (local) choice, and a\\nchoice that is forced by earlier choices. In this example, a can freely choose whether to\\nsend M1 or M2. However, the choice of b whether to receive M1 or not is not a free\\nchoice, but is forced by a\\xe2\\x80\\x99s earlier choice.\\n\\nOur semantics handles this by defining a decision structure which is used to enforce\\nconsistent choices. Formally, given a protocol \\xcf\\x84 we define d(\\xcf\\x84) as a set of decision\\nstructures (formal definition below). A decision structure is a syntactic structure that\\nmirrors the structure of \\xcf\\x84 , except that each \\xe2\\x88\\xa8 is annotated with a decision (e.g. L or\\nR). We define three operations on a decision structure: to get the sub-decision structure\\ncorresponding to the left part (denoted d.L), to get the right part (d.R) and to get the\\ndecision (L or R) associated with the current \\xe2\\x88\\xa8 node (denoted d.D). We define d(\\xcf\\x84)\\nto create a set of decision structures, each of which corresponds to the structure of \\xcf\\x84 ,\\n\\n\\n\\nOn Enactability of Agent Interaction Protocols: Towards a Unified Approach 11\\n\\nbut where all possible assignments of decisions are made. Observe that If \\xcf\\x84 contains N\\noccurrences of \\xe2\\x88\\xa8 then the set d(\\xcf\\x84) contains 2N elements.\\n\\nFor example, given \\xcf\\x84 = a\\nM1\\n=\\xe2\\x87\\x92 b\\xe2\\x88\\xa8 a M2=\\xe2\\x87\\x92 b we have that d(\\xcf\\x84) = {\\n\\nL\\n\\xe2\\x88\\xa8 ,\\n\\nR\\n\\xe2\\x88\\xa8 } where\\n\\nwe use to indicate an irrelevant part of a decision structure, and\\nL\\n\\xe2\\x88\\xa8 to denote a node\\n\\ntagged with a decision L.\\nIn addition to decisions of L and R, the definition of d(\\xcf\\x841 \\xe2\\x88\\xa8 \\xcf\\x842) has a second case\\n\\n(. . . \\xe2\\x88\\xaa {t1\\nLR\\n\\xe2\\x88\\xa8 t2 | . . .}). The reason is that it is only possible to enforce consistent\\n\\nchoice if the choice is made by a single agent. If this is not the case, then we annotate\\nwith \\xe2\\x80\\x9cLR\\xe2\\x80\\x9d to indicate that a mixed choice is possible. For example, given \\xcf\\x84 = b\\n\\nM1\\n=\\xe2\\x87\\x92\\n\\na \\xe2\\x88\\xa8 a M2=\\xe2\\x87\\x92 b we have that d(\\xcf\\x84) = {\\nLR\\n\\xe2\\x88\\xa8 } because the agents associated with the set of\\n\\npossible initial messages in each branch are different (ag(\\xcf\\x841) = {b} 6= ag(\\xcf\\x842) = {a}).\\n\\nd(\\xce\\xb5) = {\\xce\\xb5}\\nd(I) = {I}\\n\\nd(\\xcf\\x841 \\xe2\\x88\\xa8 \\xcf\\x842) = {t1\\nx\\n\\xe2\\x88\\xa8 t2 | t1 \\xe2\\x88\\x88 d(\\xcf\\x841) \\xe2\\x88\\xa7 t2 \\xe2\\x88\\x88 d(\\xcf\\x842)\\n\\xe2\\x88\\xa7 x \\xe2\\x88\\x88 {R,L} \\xe2\\x88\\xa7 ag(\\xcf\\x841) = ag(\\xcf\\x842) \\xe2\\x88\\xa7 |ag(\\xcf\\x841)| = 1}\\n\\n\\xe2\\x88\\xaa {t1\\nLR\\n\\xe2\\x88\\xa8 t2 | t1 \\xe2\\x88\\x88 d(\\xcf\\x841) \\xe2\\x88\\xa7 t2 \\xe2\\x88\\x88 d(\\xcf\\x842)\\n\\n\\xe2\\x88\\xa7 ((ag(\\xcf\\x841) 6= ag(\\xcf\\x842)) \\xe2\\x88\\xa8 (|ag(\\xcf\\x841)| 6= 1))}\\n\\nwhere ag(\\xcf\\x84) = {p | p M=\\xe2\\x87\\x92 r \\xe2\\x88\\x88 min(poset(\\xcf\\x84))}\\nd(\\xcf\\x841 \\xe2\\x8a\\x95 \\xcf\\x842) = {t1 \\xe2\\x8a\\x95 t2 | t1 \\xe2\\x88\\x88 d(\\xcf\\x841) \\xe2\\x88\\xa7 t2 \\xe2\\x88\\x88 d(\\xcf\\x842)}\\n\\n(\\xcf\\x84L \\xe2\\x8a\\x97 \\xcf\\x84R).L = \\xcf\\x84L (\\xcf\\x84L \\xe2\\x8a\\x97 \\xcf\\x84R).R = \\xcf\\x84R (\\xcf\\x84L\\nX\\n\\xe2\\x88\\xa8 \\xcf\\x84R).D = X\\n\\nWhere \\xe2\\x8a\\x97 is any operator, and \\xe2\\x8a\\x95 is any operator other than \\xe2\\x88\\xa8.\\nWe now specify the semantics of a distributed protocol, denoted J\\xcf\\x84Kdist. The se-\\n\\nmantics is defined in terms of a union over possible decision structures (first line). The\\nremaining equations for the semantics carry along the decision structure, and follow it\\nin recursive calls, and for the semantics of \\xe2\\x88\\xa8 it enacts the decision specified in the struc-\\nture, rather than considering both sub-protocols. Note that projection is defined using \\xe2\\x80\\x96\\nrather than the usual |. The difference in the semantics below is that \\xe2\\x80\\x96 passes the same\\ndecision structure to both arguments. This ensures consistency between agents, but not\\nwithin agents.\\n\\nJ\\xcf\\x84Kdist =\\n\\xe2\\x8b\\x83\\n\\ndt\\xe2\\x88\\x88d(\\xcf\\x84)\\n\\nJ\\xcf\\x84a1\\xe2\\x80\\x96 . . . \\xe2\\x80\\x96\\xcf\\x84anKdt\\n\\nJMKdt = {\\xe3\\x80\\x88M\\xe3\\x80\\x89}\\nJ\\xce\\xb5Kdt = {\\xe3\\x80\\x88\\xe3\\x80\\x89}\\n\\nJ\\xcf\\x841 \\xc2\\xb7 \\xcf\\x842Kdt = {t1 \\xe2\\x97\\xa6 t2 | t1 \\xe2\\x88\\x88 J\\xcf\\x841Kdt.L \\xe2\\x88\\xa7 t2 \\xe2\\x88\\x88 J\\xcf\\x842Kdt.R}\\nJ\\xcf\\x841 \\xe2\\x88\\xa7 \\xcf\\x842Kdt = J\\xcf\\x841Kdt.L \\xe2\\x88\\xa9 J\\xcf\\x842Kdt.R\\n\\nJ\\xcf\\x841 \\xe2\\x88\\xa8 \\xcf\\x842Kdt = if dt.D = R then J\\xcf\\x842Kdt.R else if dt.D = L then J\\xcf\\x841Kdt.L\\n\\nelse J\\xcf\\x842Kdt.R \\xe2\\x88\\xaa J\\xcf\\x841Kdt.L\\n\\n\\n\\n12 A. Ferrando et al.\\n\\nJ\\xcf\\x841|\\xcf\\x842Kdt = {z | t1 \\xe2\\x88\\x88 J\\xcf\\x841Kdt.L \\xe2\\x88\\xa7 t2 \\xe2\\x88\\x88 J\\xcf\\x842Kdt.R \\xe2\\x88\\xa7 z \\xe2\\x88\\x88 t1 ./ t2}\\nJ\\xcf\\x841\\xe2\\x80\\x96\\xcf\\x842Kdt = {z | t1 \\xe2\\x88\\x88 J\\xcf\\x841Kdt \\xe2\\x88\\xa7 t2 \\xe2\\x88\\x88 J\\xcf\\x842Kdt \\xe2\\x88\\xa7 z \\xe2\\x88\\x88 t1 ./ t2}\\n\\nwhere t1 ./ t2 is the set of all interleavings of t1 and t2, and \\xe2\\x97\\xa6 is concatenation over\\nsequences. Note that if \\xcf\\x84 does not contain any occurrences of \\xe2\\x88\\xa8 then the semantics\\nabove reduce to the standard semantics.\\n\\nFinally, we define J\\xcf\\x84iKCMdist, which computes the semantics of an interaction protocol\\n\\xcf\\x84i by distributing it, and also applies a particular communication model CM.\\n\\nJ\\xcf\\x84iKCMdist = J\\xcf\\x84iKdist \\xe2\\x88\\xa9 L\\nEI(\\xcf\\x84)\\nCM\\n\\nEnactability. We are now finally in a position to define enactability. The intuition is\\nthat an interaction protocol \\xcf\\x84 is enactable iff the semantics of \\xcf\\x84 , with respect to a se-\\nlected message ordering interpretation and communication model, can be realised by a\\ndistributed version of the protocol. In other words, if there exists for each role r a corre-\\nsponding message protocol \\xcf\\x84r such that the combination of these protocols realises the\\nsame behaviour as \\xcf\\x84 . However, instead of considering whether there exists some \\xcf\\x84r, we\\nlet \\xcf\\x84r = \\xcf\\x84 r, i.e. we take for each role the projected protocol as its protocol.\\n\\nWe also consider a notion of weak enactability. This applies in a situation where\\nthe distributed enactment is able to avoid violating the behaviour specified by \\xcf\\x84 , but is\\nnot able to recreate all of the behaviours that \\xcf\\x84 specifies. In other words, if a protocol\\nis weakly enactable, the interleaving of the corresponding local protocols generates a\\nsubset of its traces (with a fixed moi and communication model). This means that a\\ndistributed implementation of the protocol can be sound (generates only valid traces),\\nbut cannot be complete (not all the traces are generated). This situation can arise with\\nweaker message ordering interpretations (see below for examples). Weak enactability\\ncan also arise in situations where two ordered messages have two overlapping roles\\n(e.g. \\xcf\\x84 = a\\n\\nM1\\n=\\xe2\\x87\\x92 b \\xc2\\xb7 b M2=\\xe2\\x87\\x92 a). In this situation the projection operator is too strict: it has\\n\\n\\xcf\\x84 b = r(M1) \\xc2\\xb7 s(M2), but if we adopt an SR message ordering interpretation, then we\\ndo not need to ensure that M2 is sent after M1 is received, only that M1 is sent before\\nM2 is received, which role a can ensure on its own.\\n\\nDefinition 2 (Strongly/Weakly Enactable). Let \\xcf\\x84 be an interaction protocol, {a1, a2,\\n..., an} the set of agents involved in \\xcf\\x84 , moi \\xe2\\x88\\x88 MOISet a message order interpretation\\nand CM \\xe2\\x88\\x88 ComModel a communication model. We say that, \\xcf\\x84 is strongly (weakly)\\nenactable, for moi semantics in CM model iff the decomposition of \\xcf\\x84 through projection\\non its agents {a1, a2, ..., an} recognizes the same (a subset of) traces recognized by \\xcf\\x84 .\\nFormally:\\n\\nenact(\\xcf\\x84)CMmoi iff J\\xcf\\x84K\\nCM\\ndist = J\\xcf\\x84K\\n\\nCM\\nmoi\\n\\nweak enact(\\xcf\\x84)CMmoi iff J\\xcf\\x84K\\nCM\\ndist \\xe2\\x8a\\x86 J\\xcf\\x84K\\n\\nCM\\nmoi\\n\\nFigure 1 show the results of applying this definition to a number of cases, with\\ndifferent message ordering interpretation, and different communication models. These\\ntables were all generated by the Haskell implementation of the definitions in this paper,\\nin which 4and (4) denote strongly and weakly enactable, respectively. The prototype\\n\\n\\n\\nOn Enactability of Agent Interaction Protocols: Towards a Unified Approach 13\\n\\na\\nM1\\n=\\xe2\\x87\\x92 b \\xc2\\xb7 b\\n\\nM5\\n=\\xe2\\x87\\x92 c\\n\\nCM RS RR SS SR\\nCM1 4 4 4 4\\nCM2 4 (4) (4) (4)\\nCM3 4 (4) (4) (4)\\nCM4 4 (4) (4) (4)\\nCM5 4 (4) (4) (4)\\nCM6 4 (4) (4) (4)\\n\\na\\nM1\\n=\\xe2\\x87\\x92 b \\xc2\\xb7 a\\n\\nM2\\n=\\xe2\\x87\\x92 c\\n\\nCM RS RR SS SR\\nCM1 4 4 4 4\\nCM2 8 4 4 (4)\\nCM3 8 4 4 (4)\\nCM4 8 8 4 (4)\\nCM5 8 8 4 (4)\\nCM6 8 8 4 (4)\\n\\na\\nM1\\n=\\xe2\\x87\\x92 b \\xc2\\xb7 c\\n\\nM6\\n=\\xe2\\x87\\x92 b\\n\\nCM RS RR SS SR\\nCM1 4 4 4 4\\nCM2 8 4 4 (4)\\nCM3 8 4 8 (4)\\nCM4 8 4 4 (4)\\nCM5 8 4 8 (4)\\nCM6 8 4 8 (4)\\n\\na\\nM1\\n=\\xe2\\x87\\x92 b \\xc2\\xb7 c\\n\\nM4\\n=\\xe2\\x87\\x92 a\\n\\nCM RS RR SS SR\\nCM1 4 4 4 4\\nCM2 8 8 8 4\\nCM3 8 8 8 4\\nCM4 8 8 8 4\\nCM5 8 8 8 4\\nCM6 8 8 8 4\\n\\na\\nM1\\n=\\xe2\\x87\\x92 b \\xc2\\xb7 a\\n\\nM2\\n=\\xe2\\x87\\x92 b\\n\\nCM RS RR SS SR\\nCM1 4 4 4 4\\nCM2 8 4 4 (4)\\nCM3 8 4 4 (4)\\nCM4 8 4 4 (4)\\nCM5 8 4 4 (4)\\nCM6 8 (4) (4) (4)\\n\\na\\nM1\\n=\\xe2\\x87\\x92 b \\xc2\\xb7 b\\n\\nM3\\n=\\xe2\\x87\\x92 a\\n\\nCM RS RR SS SR\\nCM1 4 4 4 4\\nCM2 4 (4) (4) (4)\\nCM3 4 (4) (4) (4)\\nCM4 4 (4) (4) (4)\\nCM5 4 (4) (4) (4)\\nCM6 4 (4) (4) (4)\\n\\na\\nM1\\n=\\xe2\\x87\\x92 b \\xe2\\x88\\xa8 a\\n\\nM2\\n=\\xe2\\x87\\x92 c\\n\\nCM RS RR SS SR\\nCM1 4 4 4 4\\nCM2 4 4 4 4\\nCM3 4 4 4 4\\nCM4 4 4 4 4\\nCM5 4 4 4 4\\nCM6 4 4 4 4\\n\\na\\nM1\\n=\\xe2\\x87\\x92 b \\xe2\\x88\\xa8 b\\n\\nM3\\n=\\xe2\\x87\\x92 a\\n\\nCM RS RR SS SR\\nCM1 4 4 4 4\\nCM2 8 8 8 8\\nCM3 8 8 8 8\\nCM4 8 8 8 8\\nCM5 8 8 8 8\\nCM6 8 8 8 8\\n\\nFig. 1. Automatically generated analyses of enactability\\n\\ncounts \\xcb\\x9c300 LOC. It implements the trace expression standard semantics, message order\\ninterpretation, communication model semantics and enactability check11.\\n\\nLooking at the tables in Figure 1, we make the following observations.\\nFirstly, CM1 is quite strict: all the cases considered are enactable under CM1, re-\\n\\ngardless of the selected message ordering interpretation. This is expected: we know that\\nCM1 is quite strong.\\n\\nSecondly, for many examples there is not a difference in enactability with the differ-\\nent communication models (other than CM1). The exception is where the communica-\\ntion model corresponds to the combination of MOI and the pattern in the protocol. For\\nexample, in the top row, second table from the right, the simple protocol is enactable\\ngiven the SS message ordering interpretation only with CM2 and CM4 (and, of course,\\nCM1). This is because, for this protocol, both messages are received by the same agent\\nbut sent by different agents, and, given an RR MOI, the desired constraint that agent\\nB receives the first message before the second, can only be enforced using a commu-\\nnication model that guarantees delivery of messages to the same recipient in the order\\nin which messages were sent. Both CM2 and CM4 provide this guarantee (in fact CM4\\nprovides exactly this, and CM2 is stronger).\\n\\nThirdly, RS appears to be a good choice for message ordering interpretation, since\\nit is the only MOI where protocols are never weakly enactable. For the other message\\nordering interpretations, there are protocols that are only weakly enactable (for com-\\nmunication models other than CM1). A protocol being weakly enactable indicates that\\nthe desired behaviour specified by the MOI is too loose: it permits behaviours that the\\ndistributed realisation cannot realise. On the other hand, in the case of the left-most\\ntable on the bottom row (protocol a\\n\\nM1\\n=\\xe2\\x87\\x92 b \\xc2\\xb7 a M2=\\xe2\\x87\\x92 b), the protocol is not enactable\\n\\nunder RS (except for CM1), but is enactable under SS and under RR. Turning to SR, we\\nobserve that it seems to be too weak: almost all the protocols in the figure are enactable\\n(although in most cases only weakly enactable).\\n\\n11 The code is available (anonymously) on the web at: http://enactability.\\naltervista.org/\\n\\n\\n\\n14 A. Ferrando et al.\\n\\nReturning to the example from the introduction:\\n\\nmodifyRes = Alice\\nCanc\\n=\\xe2\\x87\\x92 Bob \\xc2\\xb7 Alice Res=\\xe2\\x87\\x92 Carol\\n\\nthis corresponds to the second table from the left in the top row of Figure 1. This shows\\nthat, if one desires an RR MOI, then the underlying message communication must be\\nCM1, CM2 or CM3, in order for the protocol to be enactable.\\n\\n4 Discussion\\n\\nDespite the large amount of work on enactability, very few approaches consider how\\nmessage ordering and decision structures affect its definition, very few come with an\\nimplemented prototype, and none considers the issues raised by the communication\\nmodel.\\n\\nTaking all these features into account in a unified semantic-driven way, and demon-\\nstrating the potential of the approach on a highly expressive protocol language, are the\\ninnovative and original features of this contribution.\\n\\nDesai and Singh [12] limit their investigation to the RS message ordering interpre-\\ntation, which they consider the standard of correctness. Hence, despite the introduction\\nthey provide to other message orderings and to the problems they might raise, the defi-\\nnition of enactability they provide is not parametric in the MOI.\\n\\nLanese et al. [18] move a step further, but the generality of their approach is still lim-\\nited. They define three different notions of enactability, which they name conformance:\\nsender conformance, receiver conformance, and disjoint conformance. That approach\\nis more flexible than the one by Desai and Singh, but less general than ours, where\\nthe definition of enactability is parametric in the MOI and does not require different\\ncases. Also, they only consider how sequence and choice are affected by MOIs, leav-\\ning the study of other operators for the future. Moreover, when discussing interaction\\nprotocols whose most external operator is a choice, they put a very strong constraint for\\nenactability, namely that the agents involved in the two branches of the choice (exclud-\\ning the agents involved in the choice itself) are the same. We added decision structures\\nto overcome this restriction, and provide a notion of enactability that can succeed even\\nwhen that constraint is not met.\\n\\nNeither Desai and Singh, nor Lanese et al., use formalisms for protocol represen-\\ntation as expressive as trace expressions, and neither of them present experiments ob-\\ntained from a working prototype, as we do.\\n\\nWith respect to the introduction of decision structures to remove unnecessary re-\\nstrictions on enactability of protocols when choice is involved, our proposal is similar\\nto that by Qiu et al., [21]. However, as for the other works we have discussed in this\\nsection, we implemented our enactability checker, whereas their work only provides\\ndefinitions. Additionally, our approach is simpler in that we do not need to label the\\nchoice operator with agents as they do, and, finally, they do not consider as general a\\nsetting (with a range of message ordering interpretations and communication seman-\\ntics).\\n\\n\\n\\nOn Enactability of Agent Interaction Protocols: Towards a Unified Approach 15\\n\\nIn the future, we will address both theoretical and practical issues. On the theoretical\\nside, we will carry out a systematic analysis of the relationships between the commu-\\nnication model and the message ordering interpretation, to identify those combinations\\nthat provide some guarantees by design. We will also explore the relationship between\\nenactability and distributed monitorability [14], since the two notions are related.\\n\\nOn the practical side, we plan to improve our working prototype to provide a tool\\nto assess protocols for enactability. Apart from providing a user-friendly interface, a\\nkey issue to address will be to provide a way to isolate the part of a non-enactable\\nprotocol that makes it non-enactable. Also, trace expressions are interpreted in a coin-\\nductive way [23] to represent infinite traces of events. Since Haskell does not support\\ncoinduction, the existing prototype can be only used on acyclic message and interaction\\nprotocols. Haskell has been chosen because the implementation mimics the semantics,\\nwhich makes it easy to check that the Haskell implementation correctly implements\\nthe formal definitions. In order to fully implement the proposed features we are plan-\\nning to develop the enactability check using SWI-Prolog12, which natively supports\\ncoinduction. We also will explore alternative approaches to dealing with cyclic trace\\nexpressions, including the possibility of translating them to (e.g.) Bu\\xcc\\x88chi automata. Ad-\\nditionally, to stress-test the prototype and assess its performance from a qualitative and\\nquantitative viewpoint we plan to create a library of interaction protocols known to be\\n\\xe2\\x80\\x9cproblematic\\xe2\\x80\\x9d with respect to enactability, and perform systematic experiments.\\n\\nFinally, this work highlighted the need to characterise existing agent infrastructures\\nsuch as JADE [5], Jason [6] and Jadex [20] in terms of the communication models\\nthey support. We asked the developers of the three frameworks, and all agreed that they\\nsupport the CM4 model, which was the answer we expected. Nevertheless, this answer\\nwas far from being trivial to identify for the developers themselves. As an example,\\nLars Braubach pointed out that Jadex uses service interaction on top of messages, i.e.\\ncommunication is fully asynchronous but based on interfaces and method calls from a\\nuser perspective, which makes answering the question more subtle than it might seem.\\nBoth Jomi Fred Hu\\xcc\\x88bner (Jason) and Agostino Poggi (JADE) recognized that they had to\\nspend some time on the issue, also because the classification CM0-CM6 based on [10]\\nrequires time to be read and understood. This suggests two further directions of work.\\nOn the one hand, we might run experiments on the three platforms above, to confirm\\ntheir CM and try to check if other models are (unexpectedly) supported. On the other,\\nthe EMAS community might devise a standard taxonomy for CMs, such as the as one in\\n[10], and provide each platform with a set of agreed upon \\xe2\\x80\\x9cplatform standard metadata\\xe2\\x80\\x9d\\n(how many agents can run concurrently without experiencing problems; learning curve\\nfor different types of professionals; known practical applications; etc). These metadata\\nshould include CM as well. This piece of information, along with the approach we have\\nproposed in this paper, would allow the developers to determine whether a protocol is\\nenactable on a given infrastructure.\\n\\n12 http://www.swi-prolog.org\\n\\n\\n\\n16 A. Ferrando et al.\\n\\nAcknowledgements\\n\\nWe thank Lars Braubach, Jomi Fred Hu\\xcc\\x88bner, and Agostino Poggi for their support in\\nunderstanding the communication model supported by Jadex, Jason, and JADE.\\n\\nReferences\\n\\n1. Ancona, D., Drossopoulou, S., Mascardi, V.: Automatic generation of self-monitoring MASs\\nfrom multiparty global session types in Jason. In: DALT. LNCS, vol. 7784, pp. 76\\xe2\\x80\\x9395.\\nSpringer (2012)\\n\\n2. Ancona, D., Ferrando, A., Franceschini, L., Mascardi, V.: Parametric trace expressions for\\nruntime verification of Java-like programs. In: FTfJP@ECOOP. pp. 10:1\\xe2\\x80\\x9310:6. ACM (2017)\\n\\n3. Ancona, D., Ferrando, A., Mascardi, V.: Comparing trace expressions and linear temporal\\nlogic for runtime verification. In: Theory and Practice of Formal Methods. LNCS, vol. 9660,\\npp. 47\\xe2\\x80\\x9364 (2016)\\n\\n4. Autili, M., Tivoli, M.: Distributed enforcement of service choreographies. In: Ca\\xcc\\x81mara,\\nJ., Proenc\\xcc\\xa7a, J. (eds.) 13th International Workshop on Foundations of Coordination Lan-\\nguages and Self-Adaptive Systems (FOCLASA). EPTCS, vol. 175, pp. 18\\xe2\\x80\\x9335 (2014).\\ndoi:http://doi.org/10.4204/EPTCS.175.210.4204/EPTCS.175.2\\n\\n5. Bellifemine, F.L., Caire, G., Greenwood, D.: Developing Multi-Agent Systems with JADE.\\nWiley (2007)\\n\\n6. Bordini, R.H., Hu\\xcc\\x88bner, J.F., Wooldridge, M.: Programming Multi-Agent Systems in Agent-\\nSpeak Using Jason (Wiley Series in Agent Technology). John Wiley & Sons (2007)\\n\\n7. Broda, S., Machiavelo, A., Moreira, N., Reis, R.: Automata for regular expressions with\\nshuffle. Information and Computation 259(2), 162\\xe2\\x80\\x93173 (2018)\\n\\n8. Carbone, M., Honda, K., Yoshida, N.: Structured communication-centred programming for\\nweb services. In: Nicola, R.D. (ed.) 16th European Symposium on Programming (ESOP).\\nLNCS, vol. 4421, pp. 2\\xe2\\x80\\x9317. Springer (2007). doi:http://doi.org/10.1007/978-3-540-71316-\\n6 210.1007/978-3-540-71316-6 2\\n\\n9. Castagna, G., Dezani-Ciancaglini, M., Padovani, L.: On global types and multi-party ses-\\nsions. In: Bruni, R., Dingel, J. (eds.) FMOODS/FORTE. LNCS, vol. 6722, pp. 1\\xe2\\x80\\x9328. Springer\\n(2011). doi:http://doi.org/10.1007/978-3-642-21461-5 110.1007/978-3-642-21461-5 1\\n\\n10. Chevrou, F., Hurault, A., Que\\xcc\\x81innec, P.: On the diversity of asynchronous communication.\\nFormal Aspects of Computing 28(5), 847\\xe2\\x80\\x93879 (2016). doi:http://doi.org/10.1007/s00165-\\n016-0379-x10.1007/s00165-016-0379-x\\n\\n11. Decker, G., Weske, M.: Local enforceability in interaction Petri nets. In: Alonso, G.,\\nDadam, P., Rosemann, M. (eds.) 5th International Conference on Business Process Man-\\nagement. LNCS, vol. 4714, pp. 305\\xe2\\x80\\x93319. Springer (2007). doi:http://doi.org/10.1007/978-3-\\n540-75183-0 2210.1007/978-3-540-75183-0 22\\n\\n12. Desai, N., Singh, M.P.: On the enactability of business protocols. In: Fox, D., Gomes, C.P.\\n(eds.) Twenty-Third AAAI Conference on Artificial Intelligence. pp. 1126\\xe2\\x80\\x931131. AAAI\\nPress (2008), http://www.aaai.org/Library/AAAI/2008/aaai08-178.php\\n\\n13. Ferrando, A., Ancona, D., Mascardi, V.: Monitoring patients with hypoglycemia using self-\\nadaptive protocol-driven agents: A case study. In: Baldoni, M., Mu\\xcc\\x88ller, J.P., Nunes, I.,\\nZalila-Wenkstern, R. (eds.) 4th International Workshop on Engineering Multi-Agent Systems\\n(EMAS). LNCS, vol. 10093, pp. 39\\xe2\\x80\\x9358. Springer (2016). doi:http://doi.org/10.1007/978-3-\\n319-50983-9 310.1007/978-3-319-50983-9 3\\n\\n\\n\\nOn Enactability of Agent Interaction Protocols: Towards a Unified Approach 17\\n\\n14. Ferrando, A., Ancona, D., Mascardi, V.: Decentralizing MAS monitoring with DecAMon. In:\\nLarson, K., Winikoff, M., Das, S., Durfee, E.H. (eds.) Proceedings of the 16th Conference\\non Autonomous Agents and MultiAgent Systems, AAMAS 2017, Sa\\xcc\\x83o Paulo, Brazil, May\\n8-12, 2017. pp. 239\\xe2\\x80\\x93248. ACM (2017), http://dl.acm.org/citation.cfm?id=\\n3091164\\n\\n15. Honda, K., Vasconcelos, V.T., Kubo, M.: Language primitives and type discipline for\\nstructured communication-based programming. In: Hankin, C. (ed.) 7th European Sym-\\nposium on Programming (ESOP). LNCS, vol. 1381, pp. 122\\xe2\\x80\\x93138. Springer (1998).\\ndoi:http://doi.org/10.1007/BFb005356710.1007/BFb0053567\\n\\n16. Honda, K., Yoshida, N., Carbone, M.: Multiparty asynchronous session types.\\nIn: Necula, G.C., Wadler, P. (eds.) 35th ACM SIGPLAN-SIGACT Symposium\\non Principles of Programming Languages (POPL). pp. 273\\xe2\\x80\\x93284. ACM (2008).\\ndoi:http://doi.org/10.1145/1328438.132847210.1145/1328438.1328472\\n\\n17. Lamport, L.: Time, clocks, and the ordering of events in a dis-\\ntributed system. Communications of the ACM 21(7), 558\\xe2\\x80\\x93565 (Jul 1978).\\ndoi:http://doi.org/10.1145/359545.35956310.1145/359545.359563\\n\\n18. Lanese, I., Guidi, C., Montesi, F., Zavattaro, G.: Bridging the gap between\\ninteraction- and process-oriented choreographies. In: Cerone, A., Gruner, S.\\n(eds.) Sixth IEEE International Conference on Software Engineering and\\nFormal Methods (SEFM). pp. 323\\xe2\\x80\\x93332. IEEE Computer Society (2008).\\ndoi:http://doi.org/10.1109/SEFM.2008.1110.1109/SEFM.2008.11\\n\\n19. Poizat, P., Salau\\xcc\\x88n, G.: Checking the realizability of BPMN 2.0 choreographies. In: 27th\\nAnnual ACM Symposium on Applied Computing (SAC). pp. 1927\\xe2\\x80\\x931934. ACM (2012).\\ndoi:http://doi.org/10.1145/2245276.223209510.1145/2245276.2232095\\n\\n20. Pokahr, A., Braubach, L., Lamersdorf, W.: Jadex: A BDI reasoning engine. In: Bordini, R.H.,\\nDastani, M., Dix, J., El Fallah Seghrouchni, A. (eds.) Multi-Agent Programming: Languages,\\nPlatforms and Applications, pp. 149\\xe2\\x80\\x93174. Springer (2005). doi:http://doi.org/10.1007/0-387-\\n26350-0 610.1007/0-387-26350-0 6\\n\\n21. Qiu, Z., Zhao, X., Cai, C., Yang, H.: Towards the theoretical foundation of chore-\\nography. In: Williamson, C.L., Zurko, M.E., Patel-Schneider, P.F., Shenoy, P.J. (eds.)\\n16th International World Wide Web Conference (WWW). pp. 973\\xe2\\x80\\x93982. ACM (2007).\\ndoi:http://doi.org/10.1145/1242572.124270410.1145/1242572.1242704\\n\\n22. Salau\\xcc\\x88n, G., Bultan, T., Roohi, N.: Realizability of choreographies using process al-\\ngebra encodings. IEEE Transactions on Services Computing 5(3), 290\\xe2\\x80\\x93304 (2012).\\ndoi:http://doi.org/10.1109/TSC.2011.910.1109/TSC.2011.9\\n\\n23. Sangiorgi, D.: On the origins of bisimulation and coinduction. ACM Transac-\\ntions on Programming Languages and Systems 31(4), 15:1\\xe2\\x80\\x9315:41 (May 2009).\\ndoi:http://doi.org/10.1145/1516507.151651010.1145/1516507.1516510\\n\\n24. Takeuchi, K., Honda, K., Kubo, M.: An interaction-based language and its typing system. In:\\nHalatsis, C., Maritsas, D.G., Philokyprou, G., Theodoridis, S. (eds.) 6th International Confer-\\nence on Parallel Architectures and Languages Europe (PARLE). LNCS, vol. 817, pp. 398\\xe2\\x80\\x93\\n413. Springer (1994). doi:http://doi.org/10.1007/3-540-58184-7 11810.1007/3-540-58184-\\n7 118\\n\\n\\n'