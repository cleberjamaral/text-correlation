b'\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n \\n\\nSoftware Engineering \\nat Google \\n\\n31 Jan 2017 \\n\\nFergus Henderson \\n<\\xe2\\x80\\x8bfergus@google.com\\xe2\\x80\\x8b> (work) or \\n\\n<\\xe2\\x80\\x8bfergus.henderson@gmail.com\\xe2\\x80\\x8b> (personal) \\n\\nAbstract \\nWe catalog and describe Google\\xe2\\x80\\x99s key software engineering practices. \\n\\nBiography \\nFergus Henderson has been a software engineer at Google for over 10 years. He started                \\nprogramming as a kid in 1979, and went on to academic research in programming language               \\ndesign and implementation. With his PhD supervisor, he co-founded a research group at the              \\nUniversity of Melbourne that developed the programming language Mercury. He has been a             \\nprogram committee member for eight international conferences, and has released over 500,000            \\nlines of open-source code. He was a former moderator of the Usenet newsgroup comp.std.c++              \\nand was an officially accredited \\xe2\\x80\\x8b\\xe2\\x80\\x9cTechnical Expert\\xe2\\x80\\x9d to the ISO C and C++ committees. \\xe2\\x80\\x8bHe has                \\nover 15 years of commercial software industry experience. At Google, he was one of the                \\noriginal developers of Blaze, a build tool now used across Google, and worked on the               \\nserver-side software behind speech recognition and voice actions (before Siri!) and speech            \\nsynthesis. He currently manages Google\\'s text-to-speech engineering team, but still writes and            \\nreviews plenty of code. Software that he has written is installed on over a billion devices, and                 \\ngets used over a billion times per day. \\n  \\n\\n \\n\\nmailto:fergus@google.com\\nmailto:fergus.henderson@gmail.com\\n\\n\\nSoftware Engineering at Google, by Fergus Henderson \\n\\nContents \\nAbstract \\n\\nBiography \\n\\nContents \\n\\n1. Introduction \\n\\n2. Software development \\n2.1. The Source Repository \\n2.2. The Build System \\n2.3. Code Review \\n2.4. Testing \\n2.5. Bug tracking \\n2.6. Programming languages \\n2.7. Debugging and Profiling tools \\n2.8. Release engineering \\n2.9. Launch approval \\n2.10. Post-mortems \\n2.11. Frequent rewrites \\n\\n3. Project management \\n3.1. 20% time \\n3.2. Objectives and Key Results (OKRs) \\n3.3. Project approval \\n3.4. Corporate reorganizations \\n\\n4. People management \\n4.1. Roles \\n4.2. Facilities \\n4.3. Training \\n4.4. Transfers \\n4.5. Performance appraisal and rewards \\n\\n5. Conclusions \\n\\nAcknowledgements \\n\\nReferences \\n\\n \\n\\n2 \\n\\n\\n\\nSoftware Engineering at Google, by Fergus Henderson \\n\\n1. Introduction \\nGoogle has been a phenomenally successful company\\xe2\\x80\\x8b. As well as the success of Google              \\nSearch and AdWords, Google has delivered many other stand-out products, including Google            \\nMaps, Google News, Google Translate, Google speech recognition, Chrome, and Android.           \\nGoogle has also greatly enhanced and scaled many products that were acquired by purchasing              \\nsmaller companies, such as YouTube, and has made significant contributions to a wide variety              \\nof open-source projects. And Google has demonstrated some amazing products that are yet to              \\nlaunch, such as self-driving cars. \\n \\nThere are many reasons for Google\\xe2\\x80\\x99s success, including enlightened leadership, great people, a             \\nhigh hiring bar, and the financial strength that comes from successfully taking advantage of an               \\nearly lead in a very rapidly growing market. But one of these reasons is that \\xe2\\x80\\x8bGoogle has                 \\ndeveloped excellent software engineering practices\\xe2\\x80\\x8b, which have helped it to succeed.           \\nThese practices have evolved over time based on the accumulated and distilled wisdom of              \\nmany of the most talented software engineers on the planet. We would like to share knowledge                \\nof our practices with the world, and to share some of the lessons that we have learned from our                   \\nmistakes along the way. \\n  \\nThe aim of this paper is to catalogue and briefly describe Google\\xe2\\x80\\x99s key software              \\nengineering practices. Other organizations and individuals can then compare and contrast           \\nthese with their own software engineering practices, and consider whether to apply some of              \\nthese practices themselves. \\n \\nMany authors (e.g. [9], [10], [11]) have written books or articles analyzing Google\\xe2\\x80\\x99s success and               \\nhistory. But most of those have dealt mainly with business, management, and culture; only a               \\nfraction of those (e.g. [1, 2, 3, 4, 5, 6, 7, 13, 14, 16, 21]) have explored the software engineering                    \\nside of things, and most explore only a single aspect; and none of them provide a brief written                  \\noverview of software engineering practices at Google as a whole, as this paper aims to do. \\n\\n2. Software development \\n\\n2.1. The Source Repository \\nMost of Google\\xe2\\x80\\x99s code is stored in a single unified source-code repository, and is              \\naccessible to all software engineers at Google\\xe2\\x80\\x8b. There are some notable exceptions,            \\nparticularly the two large open-source projects Chrome and Android, which use separate            \\nopen-source repositories, and some high-value or security-critical pieces of code for which read             \\naccess is locked down more tightly. But most Google projects share the same repository. As of                \\nJanuary 2015, this 86 terabyte repository contained a billion files, including over 9 million source               \\n\\n3 \\n\\n\\n\\nSoftware Engineering at Google, by Fergus Henderson \\n\\ncode files containing a total of \\xe2\\x80\\x8b2 billion lines of source code\\xe2\\x80\\x8b, with a history of 35 million                  \\ncommits and a change rate of 40 thousand commits per work day [18]. Write access to the                 \\nrepository is controlled: only the listed owners of each subtree of the repository can approve               \\nchanges to that subtree. But generally any engineer can access any piece of code, can check it                 \\nout and build it, can make local modifications, can test them, and can send changes for review                 \\nby the code owners, and if an owner approves, can check in (commit) those changes.               \\nCulturally, engineers are encouraged to fix anything that they see is broken and know how to fix,                 \\nregardless of project boundaries. This empowers engineers and leads to higher-quality           \\ninfrastructure that better meets the needs of those using it. \\n \\nAlmost all development occurs at the \\xe2\\x80\\x9chead\\xe2\\x80\\x9d of the repository\\xe2\\x80\\x8b, not on branches. This              \\nhelps identify integration problems early and minimizes the amount of merging work needed. It              \\nalso makes it much easier and faster to push out security fixes. \\n \\nAutomated systems run tests frequently, often after every change to any file in the transitive               \\ndependencies of the test, although this is not always feasible. These systems automatically             \\nnotify the author and reviewers of any change for which the tests failed, typically within a few                 \\nminutes. Most teams make the current status of their build very conspicuous by installing              \\nprominent displays or even sculptures with color-coded lights (green for building successfully            \\nand all tests passing, red for some tests failing, black for broken build). This helps to focus                 \\nengineers\\xe2\\x80\\x99 attention on keeping the build green. Most larger teams also have a \\xe2\\x80\\x9cbuild cop\\xe2\\x80\\x9d who                \\nis responsible for ensuring that the tests continue to pass at head, by working with the authors                 \\nof the offending changes to quickly fix any problems or to roll back the offending change. (The                 \\nbuild cop role is typically rotated among the team or among its more experienced members.)               \\nThis focus on keeping the build green makes development at head practical, even for very large                \\nteams. \\n \\nCode ownership. Each subtree of the repository can have a file listing the user ids of the                 \\n\\xe2\\x80\\x9cowners\\xe2\\x80\\x9d of that subtree. Subdirectories also inherit owners from their parent directories,            \\nalthough that can be optionally suppressed. The owners of each subtree control write access to               \\nthat subtree, as described in the code review section below. Each subtree is required to have at                 \\nleast two owners, although typically there are more, especially in geographically distributed            \\nteams. It is common for the whole team to be listed in the owners file. Changes to a subtree                   \\ncan be made by anyone at Google, not just the owners, but must be approved by an owner.                  \\nThis ensures that every change is reviewed by an engineer who understands the software being               \\nmodified. \\n \\nFor more on the source code repository at Google, see [17, 18, 21]; and for how another large                  \\ncompany deals with the same challenge, see [19]. \\n\\n2.2. The Build System \\nGoogle uses a distributed build system known as Blaze, which is responsible for compiling and               \\n\\n4 \\n\\n\\n\\nSoftware Engineering at Google, by Fergus Henderson \\n\\nlinking software and for running tests. It provides standard commands for building and testing              \\nsoftware that work across the whole repository. These standard commands and the highly             \\noptimized implementation mean that \\xe2\\x80\\x8bit is typically very simple and quick for any Google              \\nengineer to build and test any software in the repository\\xe2\\x80\\x8b. This consistency is a key enabler                \\nwhich helps to make it practical for engineers to make changes across project boundaries. \\n \\nProgrammers write \\xe2\\x80\\x9cBUILD\\xe2\\x80\\x9d files that Blaze uses to determine how to build their software. Build               \\nentities such as libraries, programs, and tests are declared using fairly high-level \\xe2\\x80\\x8bdeclarative             \\nbuild specifications that specify, for each entity, its name, its source files, and the libraries or                \\nother build entities that it depends on. These build specifications are comprised of declarations              \\ncalled \\xe2\\x80\\x9cbuild rules\\xe2\\x80\\x9d that each specify high-level concepts like \\xe2\\x80\\x9chere is a C++ library with these                \\nsource files which depends on these other libraries\\xe2\\x80\\x9d, and it is up to the build system to map                  \\neach build rule to a set of build steps, e.g. steps for compiling each source file and steps for                   \\nlinking, and for determining which compiler and compilation flags to use. \\n \\nIn some cases, notably Go programs, build files can be generated (and updated) automatically,              \\nsince the dependency information in the BUILD files is (often) an abstraction of the dependency               \\ninformation in the source files. But they are nevertheless checked in to the repository. This               \\nensures that the build system can quickly determine dependencies by analyzing only the build              \\nfiles rather than the source files, and it avoids excessive coupling between the build system and                \\ncompilers or analysis tools for the many different programming languages supported. \\n \\nThe build system\\xe2\\x80\\x99s implementation uses Google\\xe2\\x80\\x99s distributed computing infrastructure. The          \\nwork of each build is typically \\xe2\\x80\\x8bdistributed across hundreds or even thousands of machines\\xe2\\x80\\x8b.              \\nThis makes it possible to build extremely large programs quickly or to run thousands of tests in                 \\nparallel. \\n \\nIndividual build steps must be \\xe2\\x80\\x9chermetic\\xe2\\x80\\x9d: they depend only on their declared inputs.             \\nEnforcing that all dependencies be correctly declared is a consequence of distributing the build:              \\nonly the declared inputs are sent to the machine on which the build step is run. As a result the                    \\nbuild system can be relied on to know the true dependencies. Even the compilers that the build                 \\nsystem invokes are treated as inputs. \\n \\nIndividual build steps are deterministic. As a consequence, the build system can cache build               \\nresults. Software engineers can sync their workspace back to an old change number and can               \\nrebuild and will get exactly the same binary. Furthermore, this cache can be safely shared               \\nbetween different users. (To make this work properly, we had to eliminate non-determinism in              \\nthe tools invoked by the build, for example by scrubbing out timestamps in the generated output                \\nfiles.) \\n \\nThe build system is reliable. \\xe2\\x80\\x8bThe build system tracks dependencies on changes to the build               \\nrules themselves, and knows to rebuild targets if the action to produce them changed, even if                \\nthe inputs to that action didn\\xe2\\x80\\x99t, for example when only the compiler options changed. It also                \\n\\n5 \\n\\n\\n\\nSoftware Engineering at Google, by Fergus Henderson \\n\\ndeals properly with interrupting the build part way, or modifying source files during the build: in                \\nsuch cases, you need only rerun the build command. There is never any need to run the                 \\nequivalent of \\xe2\\x80\\x9cmake clean\\xe2\\x80\\x9d.  \\n \\nBuild results are cached \\xe2\\x80\\x9cin the cloud\\xe2\\x80\\x9d\\xe2\\x80\\x8b. This includes intermediate results. If another build              \\nrequest needs the same results, the build system will automatically reuse them rather than              \\nrebuilding, even if the request comes from a different user. \\n \\nIncremental rebuilds are fast. \\xe2\\x80\\x8bThe build system stays resident in memory so that for rebuilds               \\nit can incrementally analyze just the files that have changed since the last build. \\n \\nPresubmit checks. \\xe2\\x80\\x8bGoogle has tools for automatically running a suite of tests when initiating a               \\ncode review and/or preparing to commit a change to the repository. Each subtree of the               \\nrepository can contain a configuration file which determines which tests to run, and whether to               \\nrun them at code review time, or immediately before submitting, or both. The tests can be either                 \\nsynchronous, i.e. run before sending the change for review and/or before committing the             \\nchange to the repository (good for fast-running tests); or asynchronous, with the results emailed              \\nto the review discussion thread. [The review thread is the email thread on which the code                \\nreview takes place; all the information in that thread is also displayed in the web-based code                \\nreview tool.] \\n\\n2.3. Code Review \\nGoogle has built excellent web-based code review tools\\xe2\\x80\\x8b, integrated with email, that allow             \\nauthors to request a review, and allows reviewers to view side-by-side diffs (with nice color               \\ncoding) and comment on them. When the author of a change initiates a code review, the                \\nreviewers are notified by e-mail, with a link to the web review tool\\xe2\\x80\\x99s page for that change. Email                  \\nnotifications are sent when reviewers submit their review comments. In addition, automated            \\ntools can send notifications, containing for example the results of automated tests or the              \\nfindings of static analysis tools. \\n \\nAll changes to the main source code repository MUST be reviewed by at least one other                \\nengineer. In addition, if the author of a change is not one of the owners of the files being                   \\nmodified, then at least one of the owners must review and approve the change. \\n \\nIn exceptional cases, an owner of a subtree can check in (commit) an urgent change to that                 \\nsubtree \\xe2\\x80\\x8bbefore it is reviewed, but a reviewer must still be named, and the change author and                 \\nreviewer will get automatically nagged about it until the change has been reviewed and              \\napproved. In such cases, any modifications needed to address review comments must be done              \\nin a separate change, since the original change will have already been committed. \\n \\nGoogle has tools for automatically suggesting reviewer(s) for a given change, by looking at the               \\nownership and authorship of the code being modified, the history of recent reviewers, and the               \\n\\n6 \\n\\n\\n\\nSoftware Engineering at Google, by Fergus Henderson \\n\\nnumber of pending code reviews for each potential reviewer. At least one of the owners of each                 \\nsubtree which a change affects must review and approve that change. But apart from that, the                \\nauthor is free to choose reviewer(s) as they see fit. \\n \\nOne potential issue with code review is that if the reviewers are too slow to respond or are                  \\noverly reluctant to approve changes, this could potentially slow down development. The fact             \\nthat the code author chooses their reviewers helps avoid such problems, allowing engineers to              \\navoid reviewers that might be overly possessive about their code, or to send reviews for simple                \\nchanges to less thorough reviewers and to send reviews for more complex changes to more               \\nexperienced reviewers or to several reviewers. \\n \\nCode review discussions for each project are automatically copied to a mailing list designated by               \\nthe project maintainers. Anyone is free to comment on any change, regardless of whether they               \\nwere named as a reviewer of that change, both before and after the change is committed. If a                  \\nbug is discovered, it\\xe2\\x80\\x99s common to track down the change that introduced it and to comment on                 \\nthe original code review thread to point out the mistake so that the original author and reviewers                 \\nare aware of it. \\n \\nIt is also possible to send code reviews to several reviewers and then to commit the change as                  \\nsoon as one of them has approved (provided either the author or the first responding reviewer is                 \\nan owner, of course), before the other reviewers have commented, with any subsequent review              \\ncomments being dealt with in follow-up changes. This can reduce the turnaround time for              \\nreviews. \\n \\nIn addition to the main section of the repository, \\xe2\\x80\\x8bthere is an \\xe2\\x80\\x9cexperimental\\xe2\\x80\\x9d section of the                \\nrepository where the normal code review requirements are not enforced\\xe2\\x80\\x8b. However, code            \\nrunning in production must be in the main section of the repository, and engineers are very                \\nstrongly encouraged to develop code in the main section of the repository, rather than              \\ndeveloping in experimental and then moving it to the main section, since code review is most                \\neffective when done as the code is developed rather than afterwards. In practice engineers              \\noften request code reviews even for code in experimental. \\n \\nEngineers are encouraged to keep each individual change small\\xe2\\x80\\x8b, with larger changes            \\npreferably broken into a series of smaller changes that a reviewer can easily review in one go.                 \\nThis also makes it easier for the author to respond to major changes suggested during the                \\nreview of each piece; very large changes are often too rigid and resist reviewer-suggested              \\nchanges. One way in which keeping changes small is encouraged is that the code review tools                1\\n\\nlabel each code review with a description of the size of the change, with changes of 30-99 lines                  \\nadded/deleted/removed being labelled \\xe2\\x80\\x9cmedium-size\\xe2\\x80\\x9d and with changes of above 300 lines           \\nbeing labelled with increasingly disparaging labels, e.g. \\xe2\\x80\\x9clarge\\xe2\\x80\\x9d (300-999), \\xe2\\x80\\x9cfreakin huge\\xe2\\x80\\x9d           \\n\\n1 This has changed somewhat in recent years. More recent versions of the code review tools no longer use the more                     \\ndisparaging labels for large CLs, but they are still labelled with their size, e.g. \\xe2\\x80\\x9cS\\xe2\\x80\\x9d, \\xe2\\x80\\x9cM\\xe2\\x80\\x9d, \\xe2\\x80\\x9cL\\xe2\\x80\\x9d, \\xe2\\x80\\x9cXL\\xe2\\x80\\x9d. \\n\\n7 \\n\\n\\n\\nSoftware Engineering at Google, by Fergus Henderson \\n\\n(1000-1999), etc. (However, in a typically Googly way, this is kept fun by replacing these               \\nfamiliar descriptions with amusing alternatives on a few days each year, such as             \\ntalk-like-a-pirate day. :) \\n\\n2.4. Testing \\nUnit Testing is strongly encouraged and widely practiced at Google\\xe2\\x80\\x8b. All code used in              \\nproduction is expected to have unit tests, and the code review tool will highlight if source files                 \\nare added without corresponding tests. Code reviewers usually require that any change which             \\nadds new functionality should also add new tests to cover the new functionality. Mocking              \\nframeworks (which allow construction of lightweight unit tests even for code with dependencies             \\non heavyweight libraries) are quite popular. \\n \\nIntegration testing and regression testing are also widely practiced. \\n \\nAs discussed in \\xe2\\x80\\x8b\"Presubmit Checks\" above, testing can be automatically enforced as part of the               \\ncode review and commit process. \\n \\nGoogle also has automated tools for measuring test coverage. The results are also integrated              \\nas an optional layer in the source code browser. \\n \\nLoad testing prior to deployment is also de rigueur at Google. Teams are expected to               \\nproduce a table or graph showing how key metrics, particularly latency and error rate, vary with                \\nthe rate of incoming requests. \\n\\n2.5. Bug tracking \\nGoogle uses a bug tracking system called Buganizer for tracking issues: bugs, feature requests,              \\ncustomer issues, and processes (such as releases or clean-up efforts). Bugs are categorized             \\ninto hierarchical components and each component can have a default assignee and default             \\nemail list to CC. When sending a source change for review, engineers are prompted to               \\nassociate the change with a particular issue number. \\n \\nIt is common (though not universal) for teams at Google to regularly scan through open issues                \\nin their component(s), prioritizing them and where appropriate assigning them to particular            \\nengineers. Some teams have a particular individual responsible for bug triage, others do bug              \\ntriage in their regular team meetings. Many teams at Google make use of labels on bugs to                 \\nindicate whether bugs have been triaged, and which release(s) each bug is targeted to be fixed                \\nin. \\n\\n2.6. Programming languages \\nSoftware engineers at Google are strongly encouraged to program in one of five             \\n\\n8 \\n\\n\\n\\nSoftware Engineering at Google, by Fergus Henderson \\n\\nofficially-approved programming languages at Google: \\xe2\\x80\\x8bC++, Java, Python, Go, or JavaScript\\xe2\\x80\\x8b.           \\nMinimizing the number of different programming languages used reduces obstacles to code            \\nreuse and programmer collaboration. \\n \\nThere are also Google \\xe2\\x80\\x8bstyle guides for each language, to ensure that code all across the                \\ncompany is written with similar style, layout, naming conventions, etc. In addition there is a               \\ncompany-wide \\xe2\\x80\\x8breadability training process, whereby experienced engineers who care about          \\ncode readability train other engineers in how to write readable, idiomatic code in a particular               \\nlanguage, by reviewing a substantial change or series of changes until the reviewer is satisfied               \\nthat the author knows how to write readable code in that language. Each change that adds                \\nnon-trivial new code in a particular language must be approved by someone who has passed               \\nthis \\xe2\\x80\\x9creadability\\xe2\\x80\\x9d training process in that language. \\n \\nIn addition to these five languages, many \\xe2\\x80\\x8bspecialized domain-specific languages are used for             \\nparticular purposes (e.g. the build language used for specifying build targets and their             \\ndependencies). \\n \\nInteroperation between these different programming languages is done mainly using \\xe2\\x80\\x8bProtocol           \\nBuffers\\xe2\\x80\\x8b. Protocol Buffers is a way of encoding structured data in an efficient yet extensible               \\nway. It includes a domain-specific language for specifying structured data, together with a             \\ncompiler that takes in such descriptions and generates code in C++, Java, Python, for              \\nconstructing, accessing, serializing, and deserializing these objects. Google\\xe2\\x80\\x99s version of          \\nProtocol Buffers is integrated with Google\\xe2\\x80\\x99s RPC libraries, enabling simple cross-language           \\nRPCs, with serialization and deserialization of requests and responses handled automatically by            \\nthe RPC framework. \\n \\nCommonality of process is a key to making development easy even with an enormous code               \\nbase and a diversity of languages: there is a single set of commands to perform all the usual                  \\nsoftware engineering tasks (such as check out, edit, build, test, review, commit, file bug report,               \\netc.) and the same commands can be used no matter what project or language. Developers               \\ndon\\xe2\\x80\\x99t need to learn a new development process just because the code that they are editing                \\nhappens to be part of a different project or written in a different language. \\n \\n\\n2.7. Debugging and Profiling tools \\nGoogle servers are linked with libraries that provide a number of tools for debugging running               \\nservers. In case of a server crash, a signal handler will automatically dump a stack trace to a                  \\nlog file, as well as saving the core file. If the crash was due to running out of heap memory, the                     \\nserver will dump stack traces of the allocation sites of a sampled subset of the live heap objects.                  \\nThere are also web interfaces for debugging that allow examining incoming and outgoing RPCs              \\n(including timing, error rates, rate limiting, etc.), changing command-line flag values (e.g. to             \\nincrease logging verbosity for a particular module), resource consumption, profiling, and more.            \\n\\n9 \\n\\n\\n\\nSoftware Engineering at Google, by Fergus Henderson \\n\\nThese tools greatly increase the overall ease of debugging to the point where it is rare to fire up                   \\na traditional debugger such as gdb. \\n\\n2.8. Release engineering \\nA few teams have dedicated release engineers, but for most teams at Google, the release               \\nengineering work is done by regular software engineers. \\n \\nReleases are done frequently for most software; weekly or fortnightly releases are a common              \\ngoal, and some teams even release daily. This is made possible by \\xe2\\x80\\x8bautomating most of the                \\nnormal release engineering tasks\\xe2\\x80\\x8b. Releasing frequently helps to keep engineers motivated           \\n(it\\xe2\\x80\\x99s harder to get excited about something if it won\\xe2\\x80\\x99t be released until many months or even                 \\nyears into the future) and increases overall velocity by allowing more iterations, and thus more               \\nopportunities for feedback and more chances to respond to feedback, in a given time. \\n \\nA release typically starts in a fresh workspace, by syncing to the change number of the latest                 \\n\\xe2\\x80\\x9cgreen\\xe2\\x80\\x9d build (i.e. the last change for which all the automatic tests passed), and making a                \\nrelease branch. The release engineer can select additional changes to be \\xe2\\x80\\x9ccherry-picked\\xe2\\x80\\x9d, i.e.             \\nmerged from the main branch onto the release branch. Then the software will be rebuilt from                \\nscratch and the tests are run. If any tests fail, additional changes are made to fix the failures                  \\nand those additional changes are cherry-picked onto the release branch, after which the             \\nsoftware will be rebuilt and the tests rerun. When the tests all pass, the built executable(s) and                 \\ndata file(s) are packaged up. All of these steps are automated so that the release engineer                \\nneed only run some simple commands, or even just select some entries on a menu-driven UI,                \\nand choose which changes (if any) to cherry pick. \\n \\nOnce a candidate build has been packaged up, it is typically loaded onto a \\xe2\\x80\\x9c\\xe2\\x80\\x8bstaging\\xe2\\x80\\x8b\\xe2\\x80\\x9d server for                 \\nfurther \\xe2\\x80\\x8bintegration testing by small set of users\\xe2\\x80\\x8b (sometimes just the development team). \\n \\nA useful technique involves sending a copy of (a subset of) the requests from production traffic                \\nto the staging server, but also sending those same requests to the current production servers               \\nfor actual processing. The responses from the staging server are discarded, and the responses              \\nfrom the live production servers are sent back to the users. This helps ensure that any issues                 \\nthat might cause serious problems (e.g. server crashes) can be detected before putting the              \\nserver into production. \\n \\nThe next step is to usually roll out to one or more \\xe2\\x80\\x9c\\xe2\\x80\\x8bcanary\\xe2\\x80\\x8b\\xe2\\x80\\x9d servers that are \\xe2\\x80\\x8bprocessing a                  \\nsubset of the live production traffic. Unlike the \\xe2\\x80\\x9cstaging\\xe2\\x80\\x9d servers, these are processing and              \\nresponding to real users. \\n \\nFinally the release can be rolled out to all servers in all data centers. For very high-traffic,                 \\nhigh-reliability services, this is done with a \\xe2\\x80\\x8bgradual roll-out over a period of a couple of days, to                  \\nhelp reduce the impact of any outages due to newly introduced bugs not caught by any of the                  \\n\\n10 \\n\\n\\n\\nSoftware Engineering at Google, by Fergus Henderson \\n\\nprevious steps. \\n \\nFor more information on release engineering at Google, see chapter 8 of the SRE book [7]. See                 \\nalso [15]. \\n\\n2.9. Launch approval \\nThe launch of any user-visible change or significant design change requires approvals from a              \\nnumber of people outside of the core engineering team that implements the change. In              \\nparticular approvals (often subject to detailed review) are required to ensure that code complies              \\nwith legal requirements, privacy requirements, security requirements, reliability requirements         \\n(e.g. having appropriate automatic monitoring to detect server outages and automatically notify            \\nthe appropriate engineers), business requirements, and so forth. \\n \\nThe launch process is also designed to ensure that appropriate people within the company are               \\nnotified whenever any significant new product or feature launches. \\n \\nGoogle has an internal launch approval tool that is used to track the required reviews               \\nand approvals and ensure compliance with the defined launch processes for each            \\nproduct. This tool is easily customizable, so that different products or product areas can have               \\ndifferent sets of required reviews and approvals. \\n \\nFor more information about launch processes, see chapter 27 of the SRE book [7]. \\n\\n2.10. Post-mortems \\nWhenever there is a significant outage of any of our production systems, or similar mishap, the                \\npeople involved are required to write a post-mortem document. This document describes the             \\nincident, including title, summary, impact, timeline, root cause(s), what worked/what didn\\xe2\\x80\\x99t, and            \\naction items. \\xe2\\x80\\x8bThe focus is on the problems, and how to avoid them in future, not on the                  \\npeople or apportioning blame. \\xe2\\x80\\x8bThe impact section tries to quantify the effect of the incident, in                \\nterms of duration of outage, number of lost queries (or failed RPCs, etc.), and revenue. The                \\ntimeline section gives a timeline of the events leading up to the outage and the steps taken to                  \\ndiagnose and rectify it. The what worked/what didn\\xe2\\x80\\x99t section describes the lessons learnt --              \\nwhich practices helped to quickly detect and resolve the issue, what went wrong, and what               \\nconcrete actions (preferably filed as bugs assigned to specific people) can be take to reduce the                \\nlikelihood and/or severity of similar problems in future. \\n \\nFor more information on post-mortem culture at Google, see chapter 15 of the SRE book [7]. \\n\\n2.11. Frequent rewrites \\nMost software at Google gets rewritten every few years. \\n\\n11 \\n\\n\\n\\nSoftware Engineering at Google, by Fergus Henderson \\n\\n \\nThis may seem incredibly costly. Indeed, it does consume a large fraction of Google\\xe2\\x80\\x99s              \\nresources. However, it also has some crucial benefits that are key to Google\\xe2\\x80\\x99s agility and               \\nlong-term success. In a period of a few years, it is typical for the requirements for a product to                   \\nchange significantly, as the software environment and other technology around it change, and             \\nas changes in technology or in the marketplace affect user needs, desires, and expectations.              \\nSoftware that is a few years old was designed around an older set of requirements and is                 \\ntypically not designed in a way that is optimal for current requirements. Furthermore, it has               \\ntypically accumulated a lot of complexity. Rewriting code cuts away all the unnecessary             \\naccumulated complexity that was addressing requirements which are no longer so important. In             \\naddition, rewriting code is a way of transferring knowledge and a sense of ownership to newer                \\nteam members. This sense of ownership is crucial for productivity: engineers naturally put more              \\neffort into developing features and fixing problems in code that they feel is \\xe2\\x80\\x9ctheirs\\xe2\\x80\\x9d. Frequent               \\nrewrites also encourage mobility of engineers between different projects which helps to            \\nencourage cross-pollination of ideas. Frequent rewrites also help to ensure that code is written              \\nusing modern technology and methodology. \\n\\n3. Project management \\n\\n3.1. 20% time \\nEngineers are permitted to spend up to 20% of their time working on any project of their                 \\nchoice, without needing approval from their manager or anyone else. This trust in             \\nengineers is extremely valuable, for several reasons. Firstly, it allows anyone with a good idea,               \\neven if it is an idea that others would not immediately recognize as being worthwhile, to have                 \\nsufficient time to develop a prototype, demo, or presentation to show the value of their idea.                \\nSecondly, it provides management with visibility into activity that might otherwise be hidden. In              \\nother companies that don\\xe2\\x80\\x99t have an official policy of allowing 20% time, engineers sometimes              \\nwork on \\xe2\\x80\\x9cskunkwork\\xe2\\x80\\x9d projects without informing management. It\\xe2\\x80\\x99s much better if engineers can             \\nbe open about such projects, describing their work on such projects in their regular status               \\nupdates, even in cases where their management may not agree on the value of the project.                \\nHaving a company-wide official policy and a culture that supports it makes this possible.              \\nThirdly, by allowing engineers to spend a small portion of their time working on more fun stuff, it                  \\nkeeps engineers motivated and excited by what they do, and stops them getting burnt out,               \\nwhich can easily happen if they feel compelled to spend 100% of their time working on more                 \\ntedious tasks. The difference in productivity between engaged, motivated engineers and burnt            \\nout engineers is a \\xe2\\x80\\x8blot more than 20%. Fourthly, it encourages a culture of innovation. Seeing                \\nother engineers working on fun experimental 20% projects encourages everyone to do the             \\nsame. \\n\\n3.2. Objectives and Key Results (OKRs) \\n\\n12 \\n\\n\\n\\nSoftware Engineering at Google, by Fergus Henderson \\n\\nIndividuals and teams at Google are required to explicitly document their goals and to              \\nassess their progress towards these goals. Teams set quarterly and annual objectives, with              \\nmeasurable key results that show progress towards these objectives. This is done at every              \\nlevel of the company, going all the way up to defining goals for the whole company. Goals for                  \\nindividuals and small teams should align with the higher-level goals for the broader teams that               \\nthey are part of and with the overall company goals. At the end of each quarter, progress                 \\ntowards the measurable key results is recorded and each objective is given a score from 0.0 (no                 \\nprogress) to 1.0 (100% completion). OKRs and OKR scores are normally made visible across              \\nGoogle (with occasional exceptions for especially sensitive information such as highly           \\nconfidential projects), but they \\xe2\\x80\\x8bnot \\xe2\\x80\\x8bused directly as input to an individual\\xe2\\x80\\x99s performance             \\nappraisal. \\n \\nOKRs should be set high: the desired target overall average score is 65%, meaning that a team                 \\nis encouraged to set as goals about 50% more tasks than they are likely to actually accomplish.                 \\nIf a team scores significantly higher than that, they are encouraged to set more ambitious OKRs                \\nfor the following quarter (and conversely if they score significantly lower than that, they are               \\nencouraged to set their OKRs more conservatively the next quarter). \\n \\nOKRs provide a key mechanism for communicating what each part of the company is working               \\non, and for encouraging good performance from employees via social incentives\\xe2\\x80\\xa6 engineers            \\nknow that their team will have a meeting where the OKRs will be scored, and have a natural                  \\ndrive to try to score well, even though OKRs have no direct impact on performance appraisals                \\nor compensation. Defining key results that are objective and measurable helps ensure that this              \\nhuman drive to perform well is channelled to doing things that have real concrete measurable               \\nimpact on progress towards shared objectives. \\n\\n3.3. Project approval \\nAlthough there is a well-defined process for launch approvals, Google does not have a              \\nwell-defined process for project approval or cancellation. Despite having been at Google for             \\nover 10 years, and now having become a manager myself, I still don\\xe2\\x80\\x99t fully understand how such                 \\ndecisions are made. In part this is because the approach to this is not uniform across the                 \\ncompany. Managers at every level are responsible and accountable for what projects their             \\nteams work on, and exercise their discretion as they see fit. In some cases, this means that                 \\nsuch decisions are made in a quite bottom-up fashion, with engineers being given freedom to               \\nchoose which projects to work on, within their team\\xe2\\x80\\x99s scope. In other cases, such decisions are                \\nmade in a much more top-down fashion, with executives or managers making decisions about              \\nwhich projects will go ahead, which will get additional resources, and which will get cancelled. \\n\\n3.4. Corporate reorganizations \\nOccasionally an executive decision is made to cancel a large project, and then the many               \\nengineers who had been working on that project may have to find new projects on new teams.                 \\n\\n13 \\n\\n\\n\\nSoftware Engineering at Google, by Fergus Henderson \\n\\nSimilarly there have been occasional \\xe2\\x80\\x9cdefragmentation\\xe2\\x80\\x9d efforts, where projects that are split            \\nacross multiple geographic locations are consolidated into a smaller number of locations, with             \\nengineers in some locations being required to change team and/or project in order to achieve               \\nthis. In such cases, engineers are generally given freedom to choose their new team and role                \\nfrom within the positions available in their geographic location, or in the case of              \\ndefragmentation, they may also be given the option of staying on the same team and project by                 \\nmoving to a different location. \\n \\nIn addition, other kinds of corporate reorganizations, such as merging or splitting teams and              \\nchanges in reporting chains, seem to be fairly frequent occurrences, although I don\\xe2\\x80\\x99t know how               \\nGoogle compares with other large companies on that. In a large, technology-driven            \\norganization, somewhat frequent reorganization may be necessary to avoid organizational          \\ninefficiencies as the technology and requirements change. \\n\\n4. People management \\n\\n4.1. Roles \\nAs we\\xe2\\x80\\x99ll explain in more detail below, Google separates the engineering and management             \\ncareer progression ladders, separates the tech lead role from management, embeds research            \\nwithin engineering, and supports engineers with product managers, project managers, and site            \\nreliability engineers (SREs). It seems likely that at least some of these practices are important               \\nto sustaining the culture of innovation that has developed at Google. \\n \\nGoogle has a small number of different roles within engineering. Within each role, there is a                \\ncareer progression possible, with a sequence of levels, and the possibility of promotion (with              \\nassociated improvement to compensation, e.g. salary) to recognize performance at the next            \\nlevel. \\n \\nThe main roles are these: \\n \\n\\n\\xe2\\x97\\x8f Engineering Manager \\n \\nThis is the only people management role in this list. Individuals in other roles such as                \\nSoftware Engineer \\xe2\\x80\\x8bmay \\xe2\\x80\\x8bmanage people, but Engineering Managers \\xe2\\x80\\x8balways \\xe2\\x80\\x8bmanage          \\npeople. Engineering Managers are often former Software Engineers, and invariably          \\nhave considerable technical expertise, as well as people skills. \\n \\nThere is a distinction between technical leadership and people management. \\nEngineering Managers do not necessarily lead projects; projects are led by a Tech Lead,              \\nwho can be an Engineering Manager, but who is more often a Software Engineer. A               \\nproject\\xe2\\x80\\x99s Tech Lead has the final say for technical decisions in that project. \\n\\n14 \\n\\n\\n\\nSoftware Engineering at Google, by Fergus Henderson \\n\\n \\nManagers are responsible for selecting Tech Leads, and for the performance of their             \\nteams. They perform coaching and assisting with career development, do performance           \\nevaluation (using input from peer feedback, see below), and are responsible for some             \\naspects of compensation. They are also responsible for some parts of the hiring             \\nprocess. \\n \\nEngineering Managers normally directly manage anywhere between 3 and 30 people,           \\nalthough 8 to 12 is most common. \\n\\n \\n\\xe2\\x97\\x8f Software Engineer (SWE) \\n\\n \\nMost people doing software development work have this role. The hiring bar for             \\nsoftware engineers at Google is very high; by hiring only exceptionally good software             \\nengineers, a lot of the software problems that plague other organizations are avoided or              \\nminimized. \\n \\nGoogle has separate career progression sequences for engineering and         \\nmanagement\\xe2\\x80\\x8b. Although it is possible for a Software Engineer to manage people, or to              \\ntransfer to the Engineering Manager role, managing people is \\xe2\\x80\\x8bnot \\xe2\\x80\\x8ba requirement for             \\npromotion, even at the highest levels. At the higher levels, showing leadership is             \\nrequired, but that can come in many forms. For example creating great software that              \\nhas a huge impact or is used by very many other engineers is sufficient. This is                \\nimportant, because it means that people who have great technical skills but lack the              \\ndesire or skills to manage people still have a good career progression path that does not                \\nrequire them to take a management track. This avoids the problem that some             \\norganizations suffer where people end up in management positions for reasons of career             \\nadvancement but neglect the people management of the people in their team. \\n\\n \\n \\n\\n\\xe2\\x97\\x8f Research Scientist \\n \\nThe hiring criteria for this role are very strict, and the bar is extremely high, requiring                \\ndemonstrated exceptional research ability evidenced by a great publication record *and*           \\nability to write code. Many very talented people in academia who would be able to               \\nqualify for a Software Engineer role would not qualify for a Research Scientist role at               \\nGoogle; most of the people with PhDs at Google are Software Engineers rather than              \\nResearch Scientists. Research scientists are evaluated on their research contributions,          \\nincluding their publications, but apart from that and the different title, there is not really               \\nthat much difference between the Software Engineer and Research Scientist role at            \\nGoogle. Both can do original research and publish papers, both can develop new             \\nproduct ideas and new technologies, and both can and do write code and develop              \\nproducts. Research Scientists at Google usually work alongside Software Engineers, in           \\n\\n15 \\n\\n\\n\\nSoftware Engineering at Google, by Fergus Henderson \\n\\nthe same teams and working on the same products or the same research. This practice               \\nof embedding research within engineering contributes greatly to the ease with which new             \\nresearch can be incorporated into shipping products. \\n\\n \\n\\xe2\\x97\\x8f Site Reliability Engineer (SRE) \\n\\n \\nThe maintenance of operational systems is done by software engineering teams, rather            \\nthan traditional sysadmin types, but the hiring requirements for SREs are slightly            \\ndifferent than the requirements for the Software Engineer position (software engineering           \\nskills requirements can be slightly lower, if compensated for by expertise in other skills              \\nsuch as networking or unix system internals). The nature and purpose of the SRE role is                \\nexplained very well and in detail in the SRE book [7], so we won\\xe2\\x80\\x99t discuss it further here. \\n\\n \\n\\xe2\\x97\\x8f Product Manager \\n\\n \\nProduct Managers are responsible for the management of a product; as advocates for             \\nthe product users, they coordinate the work of software engineers, evangelizing features            \\nof importance to those users, coordinating with other teams, tracking bugs and            \\nschedules, and ensuring that everything needed is in place to produce a high quality              \\nproduct. Product Managers usually do NOT write code themselves, but work with            \\nsoftware engineers to ensure that the right code gets written. \\n \\n\\n\\xe2\\x97\\x8f Program Manager / Technical Program Manager \\n \\nProgram Managers have a role that is broadly similar to Product Manager, but rather              \\nthan managing a product, they manage projects, processes, or operations (e.g. data            \\ncollection). Technical Program Managers are similar, but also require specific technical           \\nexpertise relating to their work, e.g. linguistics for dealing with speech data. \\n \\nThe ratio of Software Engineers to Product Managers and Program Managers varies            \\nacross the organization, but is generally high, e.g. in the range 4:1 to 30:1. \\n\\n4.2. Facilities \\nGoogle is famous for its fun facilities, with features like slides, ball pits, and games rooms. That                 \\nhelps attract and retain good talent. Google\\xe2\\x80\\x99s excellent cafes, which are free to employees,              \\nprovide that function too, and also subtly encourage Googlers to stay in the office; hunger is                \\nnever a reason to leave. The frequent placement of \\xe2\\x80\\x9cmicrokitchens\\xe2\\x80\\x9d where employees can grab              \\nsnacks and drinks serves the same function too, but also acts as an important source of                \\ninformal idea exchange, as many conversations start up there. Gyms, sports, and on-site             \\nmassage help keep employees fit, healthy, and happy, which improves productivity and            \\nretention. \\n \\n\\n16 \\n\\n\\n\\nSoftware Engineering at Google, by Fergus Henderson \\n\\nThe seating at Google is open-plan, and often fairly dense. While controversial [20], this              \\nencourages communication, sometimes at the expense of individual concentration, and is           \\neconomical. \\n \\nEmployees are assigned an individual seat, but seats are re-assigned fairly frequently (e.g.             \\nevery 6-12 months, often as a consequence of the organization expanding), with seating chosen              \\nby managers to facilitate and encourage communication, which is always easier between            \\nadjacent or nearly adjacent individuals. \\n \\nGoogle\\xe2\\x80\\x99s facilities all have meeting rooms fitted with state-of-the-art video conference facilities,            \\nwhere connecting to the other party for a prescheduled calendar invite is just a single tap on the                  \\nscreen. \\n\\n4.3. Training \\nGoogle encourages employee education in many ways: \\n\\n\\xe2\\x97\\x8f New Googlers (\\xe2\\x80\\x9cNooglers\\xe2\\x80\\x9d) have a mandatory initial training course. \\n\\xe2\\x97\\x8f Technical staff (SWEs and research scientists) start by doing \\xe2\\x80\\x9cCodelabs\\xe2\\x80\\x9d: short online            \\n\\ntraining courses in individual technologies, with coding exercises. \\n\\xe2\\x97\\x8f Google offers employees a variety of online and in-person training courses. \\n\\xe2\\x97\\x8f Google also offers support for studying at external institutions. \\n\\n \\nIn addition, each Noogler is usually appointed an official \\xe2\\x80\\x9cMentor\\xe2\\x80\\x9d and a separate \\xe2\\x80\\x9cBuddy\\xe2\\x80\\x9d to               \\nhelp get them up to speed. Unofficial mentoring also occurs via regular meetings with their               \\nmanager, team meetings, code reviews, design reviews, and informal processes. \\n\\n4.4. Transfers \\nTransfers between different parts of the company are encouraged\\xe2\\x80\\x8b, to help spread            \\nknowledge and technology across the organization and improve cross-organization         \\ncommunication. \\xe2\\x80\\x8bTransfers between projects and/or offices are allowed for employees in good            \\nstanding after 12 months in a position. Software engineers are also encouraged to do              \\ntemporary assignments in other parts of the organization, e.g. a six-month \\xe2\\x80\\x9crotation\\xe2\\x80\\x9d (temporary             \\nassignment) in SRE (Site Reliability Engineering). \\n\\n4.5. Performance appraisal and rewards \\nFeedback is strongly encouraged at Google. Engineers can give each other explicit positive             \\nfeedback via \\xe2\\x80\\x9cpeer bonuses\\xe2\\x80\\x9d and \\xe2\\x80\\x9ckudos\\xe2\\x80\\x9d. Any employee can nominate any other employee for              \\na \\xe2\\x80\\x9cpeer bonus\\xe2\\x80\\x9d -- a cash bonus of $100 -- up to twice per year, for going beyond the normal call                     \\nof duty, just by filling in a web form to describe the reason. Team-mates are also typically                 \\nnotified when a peer bonus is awarded. Employees can also give \\xe2\\x80\\x9ckudos\\xe2\\x80\\x9d, formalized             \\nstatements of praise which provide explicit social recognition for good work, but with no financial               \\n\\n17 \\n\\n\\n\\nSoftware Engineering at Google, by Fergus Henderson \\n\\nreward; for \\xe2\\x80\\x9ckudos\\xe2\\x80\\x9d there is no requirement that the work be beyond the normal call of duty, and                  \\nno limit on the number of times that they can be bestowed. \\n \\nManagers can also award bonuses, including spot bonuses, e.g. for project completion. And as              \\nwith many companies, Google employees get annual performance bonuses and equity awards            \\nbased on their performance. \\n \\nGoogle has a very careful and detailed promotion process, which involves nomination by self or               \\nmanager, self-review, peer reviews, manager appraisals; the actual decisions are then made by             \\npromotion committees based on that input, and the results can be subject to further review by                \\npromotion appeals committees. Ensuring that the right people get promoted is critical to             \\nmaintaining the right incentives for employees. \\n \\nPoor performance, on the other hand, is handled with manager feedback, and if necessary with               \\nperformance improvement plans, which involve setting very explicit concrete performance          \\ntargets and assessing progress towards those targets. If that fails, termination for poor             \\nperformance is possible, but in practice this is \\xe2\\x80\\x8bextremely\\xe2\\x80\\x8b rare at Google. \\n \\nManager performance is assessed with feedback surveys; every employee is asked to fill in an               \\nsurvey about the performance of their manager twice a year, and the results are anonymized               \\nand aggregated and then made available to managers. This kind of upward feedback is very               \\nimportant for maintaining and improving the quality of management throughout the organization. \\n\\n5. Conclusions \\nWe have briefly described most of the key software engineering practices used at Google. Of               \\ncourse Google is now a large and diverse organization, and some parts of the organization have                \\ndifferent practices. But the practices described here are generally followed by most teams at              \\nGoogle. \\n \\nWith so many different software engineering practices involved, and with so many other reasons              \\nfor Google\\xe2\\x80\\x99s success that are not related to our software engineering practices, it is extremely               \\ndifficult to give any quantitative or objective evidence connecting individual practices with            \\nimproved outcomes. However, these practices are the ones that have stood the test of time at                \\nGoogle, where they have been subject to the collective subjective judgement of many             \\nthousands of excellent software engineers. \\n \\nFor those in other organizations who are advocating for the use of a particular practice that                \\nhappens to be described in this paper, perhaps it will help to say \\xe2\\x80\\x9cit\\xe2\\x80\\x99s good enough for Google\\xe2\\x80\\x9d. \\n\\n18 \\n\\n\\n\\nSoftware Engineering at Google, by Fergus Henderson \\n\\nAcknowledgements \\nSpecial thanks to Alan Donovan for his extremely detailed and constructive feedback, and             \\nthanks also to Y\\xe2\\x80\\x8baroslav Volovich, Urs H\\xc3\\xb6lzle, Brian Strope, Alexander Gutkin, Alex Gruenstein             \\nand Hameed Husaini for their very helpful comments on earlier drafts of this paper. \\n\\nReferences \\n[1] \\xe2\\x80\\x8bBuild in the Cloud: Accessing Source Code\\xe2\\x80\\x8b, Nathan York, \\nhttp://google-engtools.blogspot.com/2011/06/build-in-cloud-accessing-source-code.html \\n[2] \\xe2\\x80\\x8bBuild in the Cloud: How the Build System works\\xe2\\x80\\x8b, \\xe2\\x80\\x8bChristian Kemper, \\nhttp://google-engtools.blogspot.com/2011/08/build-in-cloud-how-build-system-works.htm \\n[3] \\xe2\\x80\\x8bBuild in the Cloud: Distributing Build Steps, \\xe2\\x80\\x8bNathan York \\nhttp://google-engtools.blogspot.com/2011/09/build-in-cloud-distributing-build-steps.html \\n[4] \\xe2\\x80\\x8bBuild in the Cloud: Distributing Build Outputs, \\xe2\\x80\\x8bMilos Besta, Yevgeniy Miretskiy and Jeff Cox \\nhttp://google-engtools.blogspot.com/2011/10/build-in-cloud-distributing-build.html \\n[5] \\xe2\\x80\\x8bTesting at the speed and scale of Google\\xe2\\x80\\x8b, Pooja Gupta, Mark Ivey, and John Penix, Google \\nengineering tools blog, June 2011. \\nhttp://google-engtools.blogspot.com/2011/06/testing-at-speed-and-scale-of-google.html \\n[6] \\xe2\\x80\\x8bBuilding Software at Google Scale Tech Talk, \\xe2\\x80\\x8bMichael Barnathan, Greg Estren, Pepper \\nLebeck-Jone,\\xe2\\x80\\x8b \\xe2\\x80\\x8bGoogle tech talk. \\nhttp://www.youtube.com/watch?v=2qv3fcXW1mg \\n[7] \\xe2\\x80\\x8bSite Reliability Engineering\\xe2\\x80\\x8b, Betsy Beyer, Chris Jones, Jennifer Petoff, Niall Richard Murphy, \\nO\\'Reilly Media, April 2016, ISBN 978-1-4919-2909-4. \\nhttps://landing.google.com/sre/book.html \\n[8] \\xe2\\x80\\x8bHow Google Works,\\xe2\\x80\\x8b Eric Schmidt, Jonathan Rosenberg. \\nhttp://www.howgoogleworks.net \\n[9] \\xe2\\x80\\x8bWhat would Google Do?: Reverse-Engineering the Fastest Growing Company in the History \\nof the World\\xe2\\x80\\x8b, Jeff Jarvis, Harper Business, 2011. \\nhttps://books.google.co.uk/books/about/What_Would_Google_Do.html?id=GvkEcAAACAAJ&re\\ndir_esc=y \\n[10] \\xe2\\x80\\x8bThe Search: How Google and Its Rivals Rewrote the Rules of Business and Transformed \\nOur Culture\\xe2\\x80\\x8b, John Battelle, 8 September 2005. \\nhttps://books.google.co.uk/books/about/The_Search.html?id=4MY8PgAACAAJ&redir_esc=y \\n[11] \\xe2\\x80\\x8bThe Google Story\\xe2\\x80\\x8b, David A. Vise, Pan Books, 2008. \\nhttp://www.thegooglestory.com/ \\n[12] \\xe2\\x80\\x8bSearching for Build Debt: Experiences Managing Technical Debt at Google,\\xe2\\x80\\x8b J. David \\nMorgenthaler, Misha Gridnev, Raluca Sauciuc, and Sanjay Bhansali. \\nhttp://static.googleusercontent.com/media/research.google.com/en//pubs/archive/37755.pdf \\n\\n19 \\n\\nhttp://google-engtools.blogspot.com/2011/09/build-in-cloud-distributing-build-steps.html\\nhttp://static.googleusercontent.com/media/research.google.com/en//pubs/archive/37755.pdf\\nhttp://www.thegooglestory.com/\\nhttp://www.howgoogleworks.net/\\nhttp://google-engtools.blogspot.com/2011/08/build-in-cloud-how-build-system-works.html\\nhttps://books.google.co.uk/books/about/What_Would_Google_Do.html?id=GvkEcAAACAAJ&redir_esc=y\\nhttp://google-engtools.blogspot.com/2011/06/testing-at-speed-and-scale-of-google.html\\nhttp://google-engtools.blogspot.com/2011/06/build-in-cloud-accessing-source-code.html\\nhttps://books.google.co.uk/books/about/What_Would_Google_Do.html?id=GvkEcAAACAAJ&redir_esc=y\\nhttp://google-engtools.blogspot.com/2011/10/build-in-cloud-distributing-build.html\\nhttps://landing.google.com/sre/book.html\\nhttps://books.google.co.uk/books/about/The_Search.html?id=4MY8PgAACAAJ&redir_esc=y\\nhttp://www.youtube.com/watch?v=2qv3fcXW1mg\\n\\n\\nSoftware Engineering at Google, by Fergus Henderson \\n\\n[13] \\xe2\\x80\\x8bDevelopment at the speed and scale of Google\\xe2\\x80\\x8b, A. Kumar, December 2010, presentation, \\nQCon. \\nhttp: //www.infoq.com/presentations/Development-at-Google \\n[14] \\xe2\\x80\\x8bHow Google Tests Software\\xe2\\x80\\x8b, J. A. Whittaker, J. Arbon, and J. Carollo, Addison-Wesley, \\n2012.  \\n[15] \\xe2\\x80\\x8bRelease Engineering Practices and Pitfalls\\xe2\\x80\\x8b, H. K. Wright and D. E. Perry, in \\xe2\\x80\\x8bProceedings of \\nthe 34th International Conference on Software Engineering (ICSE \\xe2\\x80\\x9912)\\xe2\\x80\\x8b, IEEE, 2012, pp. \\n1281\\xe2\\x80\\x931284. \\nhttp://www.hyrumwright.org/papers/icse2012.pdf \\n[16] \\xe2\\x80\\x8bLarge-Scale Automated Refactoring Using ClangMR\\xe2\\x80\\x8b, H. K. Wright, D. Jasper, M. Klimek, C. \\nCarruth, Z. Wan, in \\xe2\\x80\\x8bProceedings of the 29th International Conference on Software Maintenance \\n(ICSM \\xe2\\x80\\x9913)\\xe2\\x80\\x8b, IEEE, 2013, pp. 548\\xe2\\x80\\x93551. \\n[17] \\xe2\\x80\\x8bWhy Google Stores Billions of Lines of Code in a Single Repository\\xe2\\x80\\x8b, Rachel Potvin, \\npresentation. \\nhttps://www.youtube.com/watch?v=W71BTkUbdqE \\n[18] \\xe2\\x80\\x8bThe Motivation for a Monolithic Codebase\\xe2\\x80\\x8b, Rachel Potvin, Josh Levenberg, to be published \\nin Communications of the ACM, July 2016. \\n[19] \\xe2\\x80\\x8bScaling Mercurial at Facebook, \\xe2\\x80\\x8bDurham Goode, Siddharth P. Agarwa, Facebook blog post, \\nJanuary 7th, 2014. \\nhttps://code.facebook.com/posts/218678814984400/scaling-mercurial-at-facebook/ \\n[20] \\xe2\\x80\\x8bWhy We (Still) Believe In Private Offices\\xe2\\x80\\x8b, David Fullerton, Stack Overflow blog post, \\nJanuary 16th, 2015. \\nhttps://blog.stackoverflow.com/2015/01/why-we-still-believe-in-private-offices/ \\n[21] \\xe2\\x80\\x8bContinuous Integration at Google Scale\\xe2\\x80\\x8b, John Micco, presentation, EclipseCon, 2013. \\nhttp://eclipsecon.org/2013/sites/eclipsecon.org.2013/files/2013-03-24%20Continuous%20Integr\\nation%20at%20Google%20Scale.pdf \\n \\n \\n \\n\\n20 \\n\\nhttp://www.hyrumwright.org/papers/icse2012.pdf\\nhttp://www.infoq.com/presentations/Development-at-Google\\nhttps://code.facebook.com/posts/218678814984400/scaling-mercurial-at-facebook/\\nhttps://www.youtube.com/watch?v=W71BTkUbdqE\\nhttp://eclipsecon.org/2013/sites/eclipsecon.org.2013/files/2013-03-24%20Continuous%20Integration%20at%20Google%20Scale.pdf\\nhttps://blog.stackoverflow.com/2015/01/why-we-still-believe-in-private-offices/\\nhttp://eclipsecon.org/2013/sites/eclipsecon.org.2013/files/2013-03-24%20Continuous%20Integration%20at%20Google%20Scale.pdf\\n\\n'